<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构题集(C语言版)第二章]]></title>
    <url>%2F2019%2F10%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E9%9B%86-C%E8%AF%AD%E8%A8%80%E7%89%88-%E7%AC%AC%E4%BA%8C%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[基础知识题2.1①描述以下三个概念的区别：头指针，头结点，首元结点（第一个元素结点）。解答答案首元结点是指链表中存储线性表中第一个数据元素a1的结点。头结点是为了操作方便，在链表的首元结点之前附设的一个结点，该结点的数据域不存储线性表的数据元素，其作用是为了对链表进行操作时，可以对空表、非空表的情况以及对首元结点进行统一处理。头指针是指向链表中第一个结点(或为头结点或为首元结点)的指针。若链表中附设头结点，则不管线性表是否为空表，头指针均不为空，否则表示空表的链表的头指针为空。这三个概念对单链表、双向链表和循环链表均适用，是否设置头结点，是不同的存储结构表示同一逻辑结构的问题。 (选自康建伟博客, 地址: https://www.cnblogs.com/kangjianwei101/p/5221816.html) 2.2①填空题（1）在顺序表中插入或删除一个元素，需要平均移动 表中一半 元素，具体移动的元素个数与 该元素的位置 有关。&lt;/br&gt; （2）顺序表中逻辑上相邻的元素的物理位置 一定 相邻。单链表中逻辑上相邻的元素在物理位置 不一定 相邻。&lt;/br&gt; （3）在单链表中，除了首元结点外，任一结点的存储位置由 前驱结点其直接前驱结点的链域的值 指示。&lt;/br&gt; （4）在单链表中设置头结点的作用是 插入和删除首元素时不必进行特殊处理 。 2.3②在什么情况下用顺序表比链表好？解答答案不常删减元素当不需频繁在存储的元素间进行插入和删除操作时，用顺序表较好。 (选自康建伟博客, 地址: https://www.cnblogs.com/kangjianwei101/p/5221816.html) 2.4①对以下单链表分别执行下列各程序段，并画出结果示意图。 1234567891011121314151617（1）Q=P-&gt;next;（2）L=P-&gt;next;（3）R-&gt;data=P-&gt;data;（4）R-&gt;data=P-&gt;next-&gt;data;（5）P-&gt;next-&gt;next-&gt;next-&gt;data=P-&gt;data;（6）T=P; while(T!=NULL) &#123; T-&gt;data=T-&gt;data*2; T=T-&gt;next; &#125;（7）T=P; while(T-&gt;next!=NULL) &#123; T-&gt;data=T-&gt;data*2; T=T-&gt;next; &#125; 解答答案(1)不变;(2)L指向data=7的结点;(3)3改为5;(4)3改为7;(5)8改为5;(6)将5,7,3,8分别变成2倍;(7)将5,7,3,8变成2倍 2.5①画出执行下列各行语句后各指针及链表的示意图。12345678910111213L = (LinkList) malloc (sizeof(LNode)); P = L; for(i=1; i&lt;=4; i++) &#123; P-&gt;next= (LinkList) malloc (sizeof(LNode)); P = P-&gt;next; P-&gt;data = i*2-1; &#125; P-&gt;next = NULL; for(i=4; i&gt;=1; i--) Ins_LinkList(L, i+1, i*2); for(i=1; i&lt;=3; i++) Del_LinkList(L, i); 解答答案 (选自康建伟博客, 地址: https://www.cnblogs.com/kangjianwei101/p/5221816.html) 2.6②已知L是无表头结点的单链表，且P结点既不是首元结点，也不是尾元结点，试从下列提供的答案中选择合适的语句序列。 a.在P结点后插入S结点的语句序列是 （4）（1） 。 b.在P结点前插入S结点的语句序列是 （7）（11）（1） 。【(7) (11) (8) (4) (1)】 c.在表首插入S结点的语句序列是 （11）（4）（1） 。【(5) (12) 】 d.在表尾插入S结点的语句序列是 （9）（4）（1） 。【(9) (1) (6)】 123456789101112131415（1）P-&gt;next=S;（2）P-&gt;next=P-&gt;next-&gt;next;（3）P-&gt;next=S-&gt;next;（4）S-&gt;next=P-&gt;next;（5）S-&gt;next=L;（6）S-&gt;next=NULL;（7）Q=P;（8）while(P-&gt;next!=Q) P=P-&gt;next;（9）while(P-&gt;next!=NULL) P=P-&gt;next;（10）P=Q;（11）P=L;（12）L=S;（13）L=P; 2.7②已知L是带表头结点的非空单链表，且P结点既不是首元结点，也不是尾元结点，试从下列提供的答案中选择合适的语句序列。a.删除P结点的直接后继结点的语句序列是 （11）（3）（14） 。 b.删除P结点的直接前驱结点的语句序列是 （10）（12）（8）（11）（3）（14） 。 c.删除P结点的语句序列是 （10）（12）（7）（11）（3）（14） 。 d.删除首元结点的语句序列是 （12）（10）（1）（14） 。【(12) (11) (3) (14) 】 e.删除尾元结点的语句序列是 （10）（6）（14） 。【(9) (11) (3) (14) 】 12345678910111213141516171819202122（1）P=P-&gt;next; （2）P-&gt;next=P; （3）P-&gt;next=P-&gt;next-&gt;next; （4）P=P-&gt;next-&gt;next; （5）while(P!=NULL) P=P-&gt;next; （6）while(Q-&gt;next!=NULL) &#123; P=Q; Q=Q-&gt;next; &#125; （7）while(P-&gt;next!=Q) P=P-&gt;next; （8）while(P-&gt;next-&gt;next!=Q) P=P-&gt;next; （9）while(P-&gt;next-&gt;next!=NULL) P=P-&gt;next; （10）Q=P; （11）Q=P-&gt;next; （12）P=L; （13）L=L-&gt;next; （14）free(Q); 2.8②已知P结点是某双向链表的中间结点，试从下列提供的答案中选择合适的语句序列。a.在P结点后插入S结点的语句序列是 （12）（6）（7）（3） 。【(7) (12) (3) (6) 】 b.在P结点前插入S结点的语句序列是 （13）（5）（8）（4） 。【(8) (13) (5) (4) 】 c.删除P结点的直接后继结点的语句序列是 （15）（1）（11）（18） 。 d.删除P结点的直接前驱结点的语句序列是 （16）（2）（10）（18） 。 e.删除P结点的语句序列是 （9）（14）（17） 。【(14) (9) (17)】 123456789101112131415161718（1）P-&gt;next=P-&gt;next-&gt;next; （2）P-&gt;priou=P-&gt;priou-&gt;priou; （3）P-&gt;next=S; （4）P-&gt;priou=S; （5）S-&gt;next=P; （6）S-&gt;priou=P; （7）S-&gt;next=P-&gt;next; （8）S-&gt;priou=P-priou; （9）P-&gt;priou-&gt;next=P-&gt;next; （10）P-&gt;priou-&gt;next=P; （11）P-&gt;next-&gt;priou=P; （12）P-&gt;next-&gt;priou=S; （13）P-&gt;priou-&gt;next=S; （14）P-&gt;next-&gt;priou=P-&gt;priou; （15）Q=P-&gt;next; （16）Q=P-&gt;priou; （17）free(P); （18）free(Q); 2.9②简述下列算法的功能。1234567891011121314151617181920212223242526（1）Status A(LinkedList L) //L是无表头结点的单链表 &#123; if(L&amp;&amp;L-&gt;next) &#123; Q=L; L=L-&gt;next; P=L; while(P-&gt;next) P=P-&gt;next; P-&gt;next=Q; Q-&gt;next=NULL; &#125; return OK; &#125;//A （2）void BB(LNode *s, LNode *q) &#123; p=s; while(p-&gt;next!=q) p=p-&gt;next; p-&gt;next=s; &#125;//BB void AA(LNode *pa, LNode *pb) &#123;//pa和pb分别指向单循环链表中的两个结点 BB(pa, pb); BB(pb, pa); &#125;//AA 解答答案(1)把首元结点移到最后一个节点。 (2)让pa指向pb指向的那个结点。(1)如果L的长度不小于2，则将首元结点删除并插入表尾。 (2)将单循环链表拆成两个单循环链表。 算法设计题本章算法设计题涉及的顺序表和线性链表的类型定义如下： 123456789101112# define LIST_INIT_SIZE 100# define LISTINCREMENT 10typedef struct&#123; ElemType *elem; // 存储空间基址 int length; // 当前长度 int listsize; // 当前分配的存储容量&#125;SqList; // 顺序表类型typedef struct LNode&#123; ElemType data; Struct LNode *next;&#125;LNode, *LinkList; // 线性链表类型 2.10② 指出以下算法的错误和低效（即费时）之处，并将它改写为一个既正确又高效的算法。12345678910111213Status DeleteK(SqList &amp;a, int i, int k) &#123;//本过程从顺序存储结构的线性表a中删除第i个元素起的k个元素 if(i&lt;1 || k&lt;0 || i+k&gt;a.length) return INFEASIBLE; //参数不合法 else for(count=1; count&lt;k; count++) &#123;//删除一个元素 for(j=a.length; j&gt;=i+1; j--) a.elem[j-1] = a.elem[j]; a.length--; &#125; return OK; &#125;//DeleteK 解答答案低效之处：每删除一个元素后面的所有元素都要前移一位。 12345678910Status DeleteK(SqList &amp;a, int i, int k)&#123; // 本过程从顺序存储结构的线性表a中删除第i个元素起的k个元素 if (i &lt; 1 || k &lt; 0 || i+k &gt; a.length) return INFEASIBLE; // 参数不合法 else for (cout = i-1; cout &lt; a.length-i-k+1; cout++) a.elem[cout] = a.elem[cout + k]; a.length -= k; return OK;&#125;错误有两处： （1）参数不合法的判别条件不完整，合法的入口参数条件为:(删除时包括第i个元素)(0&lt;i&lt;=a,length)&amp;&amp;(0&lt;=k&lt;=a.length-i+1) （2）第二个for语句中，元素前移的次序错误。 修改如下： 12345678910Status Algo_2_10(SqList *s, int i, int k)&#123; int j; if (i &lt; 1 || i &gt; (* a).length || k &lt; 0 || i+k-1 &gt; (* a).length) return ERROR; for (j = i + k; j &lt;= (* a).length; j++) (* a).elem[j-k-1] = (* a).elem[j-1]; (* a).length -= k; return OK;&#125; ◇2.11②设顺序表va中的数据元素递增有序。试写一算法，将x插入到顺序表的适当位置上，以保持该表的有序性。解答答案123456789101112131415161718192021222324252627282930313233int InsertSqList(SqList &amp;va, ElemType x)&#123;// 操作条件：顺序表va递增有序。操作结果：将x插入到va中并保持其有序性。 ElemType *p;​ if (ListIsFull(va))​ AddLength(va);for (p = va.elem + va.length - 1; *p &gt;= x; --p) *(p+1) = *p; // 插入位置后的元素后移一位*(p+1) = x; // 插入xva.length++;return OK;&#125;bool ListIsFull(SqList &amp;va)&#123; // 操作条件：顺序表va存在。操作结果：va若满则返回TRUE，否则返回FALSE。 if (va.length &gt;= va.listsize) return TRUE; else return FALSE;&#125;int AddLength(SqList &amp;va)&#123; // 操作条件：顺序表va存在。操作结果：增加va存储容量 ElemType *newbase; if (! (newbase = (ElemType *)realloc(va.elem, (va.listsize + LISTINCREMENT) *sizeof(ElemType)))) exit(OVERFLOW); // 存储分配失败 va.elem = newbase; // 新基址 va.listsize += LISTINCREMENT; // 增加存储容量&#125;12345678910111213141516171819202122232425262728293031323334Status Algo_2_11(SqList *va, LElemType_Sq x)&#123; int i; LElemType_Sq *newbase;​ if (!(*va).length)​ return ERROR;​ if ((* va).length == (* va).listsize) // 若存储空间已满，需开辟新空间​ &#123;​ newbase = (LElemType_Sq* )realloc((* va).elem, ((* va).listsize + LISTINCREMENT)* sizeof(LElemType_Sq));​ if (!newbase)​ exit(OVERFLOW);​ (*va).elem = newbase;​ (*va).listsize += LISTINCREMENT;​ &#125;​ for (i = (* va).length; i &gt;= 1; i--)​ &#123;​ if ((* va).elem[i-1] &gt;x)​ (* va).elem[i] = (* va).elem[i - 1];​ else​ break;​ &#125;​ (* va).elem[i] = x;​ (* va).length++;​ return OK;&#125; ◇2.12③设A=(a1,…,an)和B=(b1,…,bn)均为顺序表，A’和B’分别为A和B中除去最大共同前缀后的子表（例如，A=(x,y,y,z,x,z)，B=(x,y,y,z,y,x,x,z)，则两者中最大的共同前缀为(x,y,y,z)，在两表中除去最大共同前缀后的子表分别为A’=(x,z)和B’=(y,x,x,z)）。若A’=B’=空表，则A=B；若A’=空表，而B’≠空表，或者两者均不为空表，且A’的首元小于B’的首元，则AB。试写一个比较A，B大小的算法（请注意：在算法中，不要破坏原表A和B，并且，也不一定先求得A’和B’才进行比较）。解答答案12345678910111213141516171819202122232425int CompareAandB(const SqList &amp;A, const SqList &amp;B)&#123; // 操作条件：顺序表A,B均存在。操作结果：按条件比较A,B大小,&lt;返回-1 ElemType *pa, *pb; int count, i;​ pa = A.elem;​ pb = B.elem;​ count = min(A.length, B.length);​ for (i = 1; i &lt;= count; i++) // 判断是否A,B其中一个表到尾​ &#123;​ if (*pa != *pb)​ break;​ pa++;​ pb++;​ &#125;​ if (i == count)​ if (A.length == B.length)​ return 0;​ else​ return (A.length - B.length) / abs(A.length-B.length);​ return (*pa - *pb) / abs(*pa - *pb);&#125;123456789101112131415161718192021int Algo_2_12(SqList A, SqList B)&#123; int i = 0;​ while (i &lt; A.length &amp;&amp; i &lt; B.length) // A,B均未扫描完​ &#123;​ if (A.elem[i] &gt; B.elem[i])​ return 1;​ else if (A.elem[i] &lt; B.elem[i])​ return -1;​ else​ i++; // 相等时比较下一元素​ &#125;​ if (i &lt; A.length) // A还有剩余，A大​ return 1;​ else if (i &lt; B.length) // B还有剩余，B大​ return -1;​ else​ return 0; // 同时扫描完，相等&#125; 2.13②试写一算法在带头结点的单链表结构上实现线性表操作LOCATE(L,X)。解答答案12345678910111213141516int LOCATE(LinkList L, ElemType x)&#123; // 操作条件：线性表L已存在。操作结果：在L中查找X，若存在返回其位置，否则返回0。 int i = 1; LinkList p = L-&gt;next;​ while ( p-&gt;data != x)​ &#123;​ if (p-&gt;next == NULL)​ return 0;​ i++;​ p = p-&gt;next;​ &#125;​ return i;&#125;1234567891011121314151617181920int Algo_2_13(LinkList L, LElemType_L x)&#123; int i; LinkList p;​ if (L)​ &#123;​ i = 1;​ p = L-&gt;next;​ while (p)​ &#123;​ if (p-&gt;data == x)​ return i;​ i++;​ p = p-&gt;next;​ &#125;​ &#125;​ return 0;&#125; 2.14②试写一算法在带头结点的单链表结构上实现线性表操作LENGTH(L)。解答答案1234567891011121314151617int LENGTH(LinkList L)&#123; // 操作条件：线性表L已存在。 操作结果：返回L的长度 int i = 1; LinkList p;​ if (!L)​ return 0;​ p = L-&gt;next;​ while (p-&gt;next != NULL)​ &#123;​ p = p-&gt;next;​ i++;​ &#125;​ return i;&#125;12345678910111213141516171819202122int Algo_2_14(LinkList L)&#123;​ return ListLength_L(L); // 已定义&#125;int ListLength_L(LinkList L)&#123; LinkList p; int i; if(L) &#123; i = 0; p = L-&gt;next; while(p) &#123; i++; p = p-&gt;next; &#125; &#125;​ return i;&#125; 2.15②已知指针ha和hb分别指向两个单链表的头结点，并且已知两个链表的长度分别为m和n。试写一算法将这两个链表连接在一起（即令其中一个表的首元结点连在另一个表的最后一个结点之后），假设指针hc指向连接后的链表的头结点，并要求算法以尽可能短的时间完成连接运算。请分析你的算法和时间复杂度。解答答案11 2.16③已知指针la和lb分别指向两个无头结点单链表中的首元结点。下列算法是从表la中删除自第i个元素起共len个元素后，将它们插入到表lb中的第j个元素之前。试问此算法是否正确？如有错，则请改正之。123456789101112131415161718192021222324252627Status DeleteAndInsertSub (LinkedList la, LinkedList lb,int i, int j, int len) &#123; if(i&lt;0 || j&lt;0 || len&lt;0) return INFEASIBLE; p=la; k=1; while(k&lt;i) &#123; p=p-&gt;next; k++; &#125; q=p; while(k&lt;=len) &#123; q=q-&gt;next; k++; &#125; s=lb; k=1; while(k&lt;j) &#123; s=s-&gt;next; k++; &#125; s-&gt;next=p; q-&gt;next=s-&gt;next; return OK; &#125;//DeleteAndInsertSub 解答答案123456不正确。1. k&lt;=len 改为 k&lt;=i+len-1;2. s-&gt;next=p 和 q-&gt;next=s-&gt;next 调换;原表也要处理…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657Status Algo_2_16(LinkList *la, LinkList *lb, int i, int j, int len)&#123; LinkList p, q, s, prep; int k;​ if (i &lt; 0 || j &lt; 0 || len &lt; 0)​ return INFEASIBLE;​ p = * la;​ k = 1;​ prep = NULL;​ while (p &amp;&amp; k &lt; i) // 在la中查找第i个结点，用p标记​ &#123;​ prep = p;​ p = p-&gt;next;​ k++;​ &#125;​ if (!p) // 找不到第i个元素​ return INFEASIBLE;​ q = p; // p指向la表中第i个元素​ while (q &amp;&amp; k &lt; i+len-1) // 查找la表中第i+len-1个结点，用q标记​ &#123;​ q = q-&gt;next;​ k++;​ &#125;​ if (!q)​ return INFEASIBLE;​ if (!prep) // i= 1 的情况​ *la = q-&gt;next;​ else //完成删除​ prep-&gt;next = q-&gt;next;​ if (j == 1)​ &#123;​ q-&gt;next = *lb;​ *lb = p;​ &#125;​ else​ &#123;​ s = * lb;​ k = 1;​ while (s &amp;&amp; k&lt;j-1) // 查找lb表中第j-1个元素​ &#123;​ s = s-&gt;next;​ k++;​ &#125;​ if (!s)​ return INFEASIBLE;​ q-&gt;next = s-&gt;next;​ s-&gt;next = p; // 完成插入​ return OK;​ &#125;&#125; 2.17②试写一算法，在无头结点的动态单链表上实现线性表操作INSERT(L, i, b)，并和在带头结点的动态单链表上实现相同操作的算法进行比较。解答答案11 2.18②同2.17题要求。试写一算法，实现线性表操作DELETE(L, i)。解答答案11 ◇2.19③ 已知线性表中的元素以值递增有序排列，并以单链表作存储结构。试写一高效的算法，删除表中所有值大于mink且小于maxk的元素（若表中存在这样的元素），同时释放被删结点空间，并分析你的算法的时间复杂度（注意：mink和maxk是给定的两个参变量，它们的值可以和表中的元素相同，也可以不同）。解答答案123456789101112131415161718192021int DeleteNodeMinkToMaxk(LinkList L,const int mink,const int maxk)&#123; // 操作条件：L是递增单链表。操作结果：删除L中所有值大于mink且小于maxk的元素，同时释放被删结点空间。 LinkList p, q;​ if (!L)​ return ERROR;​ p = L;​ while (p-&gt;next-&gt;data &lt; mink)​ p = p-&gt;next; // p指向值小于mink的最后一个元素​ q = p-&gt;next; // q指向值大于mink的第一个元素​ while (q-&gt;data &lt; maxk)​ &#123;​ p-&gt;next = q-&gt;next;​ free(q);​ q = p-&gt;next;​ &#125;​ return 0;&#125; 时间复杂度：O(Length(L))123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Status Algo_2_19_1(LinkList L, int mink, int maxk)&#123; LinkList p, pre, s;​ if (!L || !L-&gt;next) // L不存在或为空表时，无法删除​ return ERROR;​ if (mink &gt;= maxk) // 阈值设置错误​ return ERROR;​ pre = L;​ p = pre-&gt;next; // p指向首结点​ while (p &amp;&amp; p-&gt;data &lt; maxk) // 上限​ &#123;​ if (p-&gt;data &lt;= mink) // 下限​ &#123;​ pre = p;​ p = p-&gt;next;​ &#125;​ else // 删掉满足条件的点​ &#123;​ s = p;​ pre-&gt;next = p-&gt;next;​ p = p-&gt;next;​ free(s);​ &#125;​ &#125;​ return OK;&#125;Status Algo_2_19_2(LinkList L, int mink, int maxk)&#123; LinkList p, pre, s;​ if (!L || !L-&gt;next) // L不存在或为空表时，无法删除​ return ERROR;​ if (mink &gt;= maxk) // 阈值设置错误​ return ERROR;​ pre = L;​ p = pre-&gt;next; // p指向首结点​ while (p &amp;&amp; p-&gt;data &lt;= mink) // 下限​ &#123;​ pre = p;​ p = p-&gt;next;​ &#125;​ if(p)​ &#123;​ while (p &amp;&amp; p-&gt;data &lt; maxk) // 上限​ &#123;​ s = p;​ pre-&gt;next = p-&gt;next;​ p = p-&gt;next;​ free(s);​ &#125;​ return OK;​ &#125;&#125; 时间复杂度：最坏的情况是全部扫描完也没找到适合的元素，故时间复杂度与链表长度有关， 为O(Length(L))。 2.20② 同2.19题条件（递增有序排列），试写一高效的算法，删除表中所有值相同的多余元素（使得操作后的线性表中所有元素的值均不相同），同时释放被删结点空间，并分析你的算法的时间复杂度。解答答案1234567891011121314151617181920212223242526int DeleteSameNode(LinkList L)&#123; // 操作条件：L是递增单链表。操作结果：删除值相同的多余元素，同时释放被删结点空间。 LinkList p, q;​ if (!L)​ return ERROR;​ p = L-&gt;next;​ while (p-&gt;next != NULL)​ &#123;​ if (p-&gt;data != p-&gt;next-&gt;data)​ &#123;​ p = p-&gt;next;​ continue;​ &#125;​ else // p-&gt;data == p-&gt;next-&gt;data,删除与p值相同的p-&gt;next​ &#123;​ q = p-&gt;next;​ p -&gt;next = q-&gt;next;​ free(q);​ continue;​ &#125;​ &#125;​ return OK;&#125; 时间复杂度：O(Length(L))123456789101112131415161718192021222324252627Status Algo_2_20(LinkList L)&#123; LinkList p, pre, s;​ if (!L || !L-&gt;next) // L不存在或为空表时，无法删除​ return ERROR;​ pre = L-&gt;next;​ p = pre-&gt;next; // p指向首结点​ while (p)​ &#123;​ if (pre-&gt;data == p-&gt;data)​ &#123;​ s = p;​ pre-&gt;next = p-&gt;next;​ p = p-&gt;next;​ free(s);​ &#125;​ else​ &#123;​ pre = p;​ p = p-&gt;next;​ &#125;​ &#125;​ return OK;&#125; ◇2.21③ 试写一算法，实现顺序表的就地逆置，即利用原表的存储空间将线性表(a1, a2, …, an)逆置为(an, an-1, …, a1)。解答答案123456789101112131415161718192021int ReverseSqList(SqList L)&#123; // 操作条件：顺序表L已存在。 操作结果：对L实现就地逆置 ElemType * p, * q; int i;​ p = L.elem; // p指向表头​ q = p + L.length - 1; // q指向表尾​ for (i = 0; i &lt; L.length/2; i++)​ &#123;​ * p += * q; // 交换值​ * q = * p - * q;​ * p -= * q;​ p++;​ q--;​ &#125;​ return OK;&#125;1234567891011121314151617Status Algo_2_21(SqList L)&#123; int i, j; LElemType_Sq tmp;​ if (L.length == 0)​ return ERROR;​ for (j = 1, i = (L.length)/2; j &lt;= i; j++)​ &#123;​ tmp = L.elem[j - 1];​ L.elem[j - 1] = L.elem[L.length - j];​ L.elem[L.length - j] = tmp;​ &#125;​ return OK;&#125; ◇2.22③ 试写一算法，对单链表实现就地逆置。解答答案12345678910111213141516171819202122232425262728int ReverseLinkList(LinkList L)&#123; // 操作条件：单链表L已存在。操作结果：对L实现就地逆置。 LinkList p, q, r;​ if (!L)​ return ERROR; // 空表​ p = L-&gt;next;​ q = p-&gt;next;​ if (!q)​ return OK; // 只有一个结点​ r = q-&gt;next;​ p-&gt;next = NULL;​ while (r)​ &#123;​ q-&gt;next = p;​ p = q;​ q = q-&gt;next;​ r = q-&gt;next;​ &#125;​ q-&gt;next = p;​ L-&gt;next = q;​ return OK;&#125;1234567891011121314151617181920Status Algo_2_22(LinkList L)&#123; LinkList pre, p;​ if (!L || !L-&gt;next) // 链表不存在或链表为空​ return ERROR;​ p = L-&gt;next;​ L-&gt;next = NULL;​ while (p) // 头插法​ &#123;​ pre = p;​ p = p-&gt;next;​ pre-&gt;next = L-&gt;next;​ L-&gt;next = pre;​ &#125;​ return OK;&#125; 2.23③ 设线性表A=(a1, a2, …, am)，B=(b1, b2, …, bn)，试写一个按下列规则合并A，B为线性表C的算法，即使得C=(a1, b1, …, am, bm, bm+1, …, bn) 当m&lt;=n时；或者 C=(a1, b1, …, an, bn, an+1, …, am) 当m&gt;n时。线性表A，B和C均以单链表作存储结构，且C表利用A表和B表中的结点空间构成。注意：单链表的长度值m和n均未显式存储。解答答案1234567891011121314151617181920212223242526272829303132int ConnectAAndB(LinkList A, LinkList B)&#123; // 操作条件：单链表A，B已存在。操作结果：AB表按条件合成表C LinkList p, p1, q, q1, C;​ p = A-&gt;next;​ p1 = p-&gt;next;​ q = B-&gt;next;​ q1 = q-&gt;next;​ while (p1 &amp;&amp; q1)​ &#123;​ p-&gt;next = q;​ q-&gt;next = p1;​ p = p1;​ q = q1;​ p1 = p1-&gt;next;​ q1 = q1-&gt;next;​ &#125;​ if (p1)​ q-&gt;next = p1;​ else if (q1)​ p-&gt;next = q1;​ C = A;​ return OK;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576Status Algo_2_23_1(LinkList La, LinkList *Lb, LinkList *Lc)&#123; // 方法一：顺序链接 LinkList prea, pa, pb;​ if (!La || !(*Lb) || (!La-&gt;next &amp;&amp; !(*Lb)-&gt;next)) // La或Lb有一个不存在或两个均为空表时，合并错误​ return ERROR;​ *Lc = La; // 利用A的头结点作C的头结点​ prea = La;​ pa = La-&gt;next;​ pb = ( * Lb)-&gt;next;​ while (pa &amp;&amp; pb)​ &#123;​ ( * Lb)-&gt;next = pb-&gt;next;​ prea = pa;​ pa = pa-&gt;next;​ prea-&gt;next = pb;​ pb-&gt;next = pa;​ prea = pb;​ pb = ( * Lb)-&gt;next;​ &#125;​ if (!pa) // Lb还有剩余​ prea-&gt;next = pb;​ free(( * Lb));​ * Lb = NULL;​ return OK;​ &#125;​ Status Algo_2_23_2(LinkList La, LinkList * Lb, LinkList * Lc)​ &#123; // 方法二：交替链接​ LinkList cur, pa, pb;​ int i = 0;​ if (!La || !( * Lb) || (!La-&gt;next &amp;&amp; !( * Lb)-&gt;next)) // La或Lb有一个不存在或两个均为空表时，合并错误​ return ERROR;​ *Lc = La; // 利用A的头结点作C的头结点​ cur = ( * Lc);​ pa = La-&gt;next;​ pb = ( * Lb)-&gt;next;​ while (pa &amp;&amp; pb)​ &#123;​ i++;​ if (i%2)​ &#123;​ cur-&gt;next = pa;​ cur = pa;​ pa = pa-&gt;next;​ &#125;​ else​ &#123;​ cur-&gt;next = pb;​ cur = pb;​ pb = pb-&gt;next;​ &#125;​ &#125;​ if (!pa) // La先扫描完​ cur-&gt;next = pb;​ if (!pb) // Lb先扫描完，注意与方法一的区别​ cur-&gt;next = pa;​ free(( * pb));​ * Lb = NULL;​ return OK;&#125; ◇2.24④ 假设有两个按元素值递增有序排列的线性表A和B，均以单链表作存储结构，请编写算法将A表和B表归并成一个按元素值递减有序（即非递增有序，允许表中含有值相同的元素）排列的线性表C，并要求利用原表（即A表和B表）的结点空间构造C表。解答答案12345678910111213141516171819202122232425262728293031323334353637int AddAndReverse(LinkList A, LinkList B, LinkList C)&#123; // 操作条件：单链表A和B均按值递增有序。操作结果：将AB归并成一个递减有序的表C LinkList p, p1, q, q1;​ p = A-&gt;next;​ p1 = p-&gt;next;​ q = B-&gt;next;​ q1 = q-&gt;next;​ while (p1 &amp;&amp; q1) // 比较data大小，递增排列​ &#123;​ if (p-&gt;data &gt;= q-&gt;data)​ &#123;​ q-&gt;next = p;​ q = q1;​ q1 = q1-&gt;next;​ &#125;​ else​ &#123;​ p-&gt;next = q;​ p = p1;​ p1 = p1-&gt;next;​ &#125;​ &#125; // while​ if (p1)​ q-&gt;next = p1;​ else if (q1)​ p-&gt;next = q1;​ if (A-&gt;next-&gt;data &gt; B-&gt;next-&gt;data)​ C = ReverseLinkList(A); // 使用2.22的程序进行逆置​ else ​ C = ReverseLinkList(B);​ return OK;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Status Algo_2_24(LinkList La, LinkList *Lb, LinkList *Lc)&#123; LinkList pa, pb, s;​ if (!La || !(* Lb) || (!La-&gt;next &amp;&amp; !(* Lb)-&gt;next)) // La或Lb有一个不存在或两个均为空表时，合并错误​ return ERROR;​ *Lc = La; // 利用A的头结点作C的头结点​ pa = La-&gt;next;​ pb = ( * Lb)-&gt;next;​ La-&gt;next = NULL;​ while (pa &amp;&amp; pb) // 采用头插法建立递减链表​ &#123;​ if (pa-&gt;data &lt;= pb-&gt;data)​ &#123;​ s = pa-&gt;next;​ pa-&gt;next = La-&gt;next;​ La-&gt;next = pa;​ pa = s;​ &#125;​ else​ &#123;​ s = pb-&gt;next;​ pb-&gt;next = La-&gt;next;​ La-&gt;next = pb;​ pb = s;​ &#125;​ &#125;​ while (pa)​ &#123;​ s = pa-&gt;next;​ pa-&gt;next = La-&gt;next;​ La-&gt;next = pa;​ pa = s;​ &#125;​ while (pb)​ &#123;​ s = pb-&gt;next;​ pb-&gt;next = La-&gt;next;​ La-&gt;next = pb;​ pb = s;​ &#125;​ free( * Lb);​ return OK;&#125; 2.25④ 假设以两个元素依值递增有序排列的线性表A和B分别表示两个集合（即同一表中的元素值各不相同），现要求另辟空间构成一个线性表C，其元素为A和B中元素的交集，且表C中的元素也依值递增有序排列。试对顺序表编写求C的算法。解答答案12345678910111213141516171819202122232425int AAndB_Sq(SqList A, SqList B)&#123; // 操作条件：线性表AB存在且递增有序。 操作结果：另辟空间C存放AB交集且递增有序 SqList C, p, q;​ InitList(C); // bo2-1.cpp​ p = A;​ q = B;​ while (p &amp;&amp; q)​ &#123;​ if (p.elem == q.elem)​ &#123;​ ListInsert(C, C.length+1, p-&gt;data); // bo2-1.cpp​ p++;​ q++;​ &#125;​ else if (p.elem &gt; q.elem)​ q++;​ else​ p++;​ &#125;​ return OK;&#125;12345678910111213141516171819202122232425void Algo_2_25(SqList La, SqList Lb, SqList *Lc)&#123; int i, j, k;​ i = j = 0;​ k = 1;​ while (i &lt; La.length &amp;&amp; j &lt; Lb.length)​ &#123;​ if (La.elem[i] &lt; Lb.elem[j])​ i++;​ else if (La.elem[i] &gt; Lb.elem[j])​ j++;​ else​ &#123;​ ListInsert_Sq(Lc, k, La.elem[i]);​ k++;​ i++;​ j++;​ &#125;​ &#125;&#125; 2.26④ 要求同2.25题。试对单链表编写求C的算法。解答答案1234567891011121314151617181920212223242526int AAndB_Link(LinkList A, LinkList B)&#123; LinkList C, p, q; int i = 1;​ InitList(C); // bo2-2.cpp​ p = A-&gt;next;​ q = B-&gt;next;​ while (p &amp;&amp; q)​ &#123;​ if (p-&gt;data == q-&gt;data)​ &#123;​ LinkInsert(C, i, p-&gt;data); // bo2-2.cpp​ i++;​ p = p-&gt;next;​ q = q-&gt;next;​ &#125;​ else if (p-&gt;data &gt; q-&gt;data)​ q = q-&gt;next;​ else ​ p = p-&gt;next;​ &#125;​ return OK;&#125;123456789101112131415161718192021222324252627282930313233343536Status Algo_2_26(LinkList La, LinkList Lb, LinkList Lc)&#123; LinkList pa, pb, pc, s;​ if (!La || !Lb)​ return ERROR;​ pa = La-&gt;next;​ pb = Lb-&gt;next;​ pc = Lc;​ while (pa &amp;&amp; pb)​ &#123;​ if (pa-&gt;data == pb-&gt;data)​ &#123;​ s = (LinkList)malloc(sizeof(LNode));​ if (!s)​ exit(OVERFLOW);​ s-&gt;data = pa-&gt;data;​ s-&gt;next = NULL;​ pc-&gt;next = s;​ pc = pc-&gt;next;​ pa = pa-&gt;next;​ pb = pb-&gt;next;​ &#125;​ else if (pa-&gt;data &lt; pb-&gt;data)​ pa = pa-&gt;next;​ else​ pb = pb-&gt;next;​ &#125;​ return OK;&#125; ◇2.27④对2.25题的条件作以下修改，对顺序表重新编写求得表C的算法。（1）假设在同一表（A或B）中可能存在值相同的元素，但要求新生成的表C中的元素值各不相同； （2）利用A表空间存放表C。 解答答案123456789101112131415161718192021222324252627282930313233343536int AAndB_Sq(SqList A, SqList B)&#123; // 操作条件：线性表AB存在且递增有序。 操作结果：生成值各不相同的C且利用A空间存放C SqList C; int i = 0, j = 0; int k = 0;​ if (!A || !B)​ return ERROR;​ while (A.elem[i] &amp;&amp; B.elem[j])​ &#123;​ if (A.elem[i] == B.elem[j])​ &#123;​ if (A.elem[i] == A.elem[k]) //相同元素跳过​ &#123;​ i++;​ j++;​ continue;​ &#125;​ A.elem[k] = A.elem[i];​ i++;​ j++;​ k++;​ &#125;​ else if (A.elem[i] &gt; B.elem[j])​ j++;​ else​ i++;​ &#125;​ A.length = k;​ C=A;​ return OK;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void Algo_2_27_1(SqList La, SqList Lb, SqList *Lc)&#123; int i, j, k;​ i = j = 0;​ k = 1;​ while (i &lt; La.length &amp;&amp; j &lt; Lb.length)​ &#123;​ if (La.elem[i] &lt; Lb.elme[j])​ i++;​ else if (La.elem[i] &gt; Lb.elem[j])​ j++;​ else​ &#123;​ if (!i || La.elem[i] != La.elem[i - 1])​ &#123;​ ListInsert_Sq(Lc, k, La.elem[i]);​ k++;​ &#125;​ i++;​ j++;​ &#125;​ &#125;&#125;void Algo_2_27_2(SqList * La, SqList Lb)&#123; int i, j, k; int len_a;​ i = j = k = 0;​ len_a = 0;​ while (i &lt; (* La).length &amp;&amp; j &lt; Lb.length)​ &#123;​ if ((* La).elem[i] &lt; Lb.elem[j])​ i++;​ else if ((* La).elem[i] &gt; Lb.elem[j])​ j++;​ else​ &#123;​ if (!i || (* La).elem[i]!= (* La).elem[i-1])​ &#123;​ (* La).elem[k] = (* La).elem[i];​ len_a++;​ k++;​ &#125;​ i++;​ j++;​ &#125;​ &#125;​ (* La).length = len_a;&#125; ◇2.28④对2.25题的条件作以下两点修改，对单链表重新编写求得表C的算法。（1）假设在同一表（A或B）中可能存在值相同的元素，但要求新生成的表C中的元素值各不相同。 ​ （2）利用原表（A表或B表）中的结点构造表C，并释放A表中的无用结点空间。 解答答案12345678910111213141516171819202122232425262728293031323334353637int AAndB_Link(LinkList A, LinkList B)&#123; LinkList C, p, q, r; int i = 0;​ p = A-&gt;next;​ q = B-&gt;next;​ r = A-&gt;next;​ C = A;​ while (p &amp;&amp; q)​ &#123;​ if (p-&gt;data == q-&gt;data)​ &#123;​ if (p-&gt;data == r-&gt;data) // 相同元素跳过​ &#123;​ p = p-&gt;next;​ q = q-&gt;next;​ continue;​ &#125;​ r-&gt;data = p-&gt;data;​ p = p-&gt;data;​ q = q-&gt;data;​ &#125;​ else if (p-&gt;data &gt; q-&gt;data)​ q = q-&gt;next;​ else ​ p = p-&gt;next;​ &#125;​ DestroyList(r); // 销毁A中剩余无用结点，bo2-2.cpp​ return OK;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485Status Algo_2_28_1(LinkList La, LinkList Lb, LinkList Lc)&#123; LinkList pa, pb, pc, s;​ if (!La || !Lb)​ return ERROR;​ pa = La-&gt;next;​ pb = Lb-&gt;next;​ pc = Lc;​ while (pa &amp;&amp; pb)​ &#123;​ if (pa-&gt;data == pb-&gt;data)​ &#123;​ if (pc == Lc || pc-&gt;data != pa-&gt;data)​ &#123;​ s = (LinkList)malloc(sizeof(LNode));​ if(!s)​ exit(OVERFLOW);​ s-&gt;data = pa-&gt;data;​ s-&gt;next = NULL;​ pc-&gt;next = s;​ pc = pc-&gt;next;​ &#125;​ pa = pa-&gt;next;​ pb = pb-&gt;next;​ &#125;​ else if (pa-&gt;data &lt; pb-&gt;data)​ pa = pa-&gt;next;​ else​ pb = pb-&gt;next;​ &#125;​ return OK;&#125;Status Algo_2_28_2(LinkList La, LinkList Lb)&#123; LinkList pa, pb, p;​ if (!La || !Lb)​ return ERROR;​ pa = La-&gt;next;​ pb = Lb-&gt;next;​ p = La;​ while (pa &amp;&amp; pb)​ &#123;​ if (pa-&gt;data == pb-&gt;data)​ &#123;​ if (p == La || p-&gt;data != pa-&gt;data)​ &#123;​ p-&gt;next = pa;​ p = pa;​ pa = pa-&gt;next;​ &#125;​ else​ &#123;​ p-&gt;next = pa-&gt;next;​ free(pa);​ pa = p-&gt;next;​ &#125;​ pb = pb-&gt;next;​ &#125;​ else if (pa-&gt;data &lt; pb-&gt;data)​ &#123;​ p-&gt;next = pa-&gt;next;​ free(pa);​ pa = p-&gt;next;​ &#125;​ else​ pb = pb-&gt;next;​ &#125;​ return OK;&#125; ◇2.29⑤ 已知A，B和C为三个递增有序的线性表，现要求对A表作如下操作：删去那些既在B表中出现，又在C表中出现的元素。试对顺序表编写实现上述操作的算法，并分析你的算法的时间复杂度（注意：同一表中各元素值可能相同）。解答答案12345678910111213141516171819202122232425262728293031323334353637383940int DeleteBAndCFromA_Sq(SqList A, SqList B, SqList C)&#123; // 操作条件：顺序表ABC均为递增有序。操作结果：从A中删除B和C的交集。 int i,j,k, m, count; i = j = k = 0; count = 0;​ if (!A || !B || !C)​ return ERROR;​ while (i &lt;= A.length &amp;&amp; j &lt;= B.length &amp;&amp; k &lt;= C.length)​ &#123;​ if (B.elem[j] == C.elem[k])​ &#123;​ while (A.elem[i] &lt; B.elem[j])​ i++;​ if (A.elem[i] == B.elem[j]) // A中找到既在B表中出现，又在C表中出现的元素​ &#123;​ for (m = i; m &lt; A.length; m++) // 后面元素均前移一位​ A.elem[m] = A.elem[m+1];​ A.length--;​ count++;​ i++;​ j++;​ k++;​ continue;​ &#125;​ j++;​ k++;​ &#125;​ else if (B.elem[j] &lt; C.elem[k])​ j++;​ else​ k++;​ &#125;​ A.length = count;​ return OK;&#125; 时间复杂度：最坏情况是ABC三表均全部扫描完，O(A.length + B.length + C.length)1234567891011121314151617181920212223242526272829303132333435363738394041424344void Algo_2_29(SqList * La, SqList Lb, SqList Lc)&#123; int i, j, k, count;​ i = j = k = 0;​ count = 0;​ while (i &lt; (* La).length &amp;&amp; j &lt; Lb.length &amp;&amp; k &lt; Lc.length)​ &#123;​ if (Lb.elem[j] &lt; Lc.elem[k])​ j++;​ else if (Lb.elem[j] &gt; Lc.elem[k])​ k++;​ else​ &#123;​ while (i &lt; (* La).length &amp;&amp; (* La).elem[i] &lt; Lb.elem[j])​ &#123;​ (* La).elem[count] = (* La).elem[i];​ count++;​ i++;​ &#125;​ while (i &lt; (* La).length &amp;&amp; (* La).elem[i] == Lb.elem[j])​ i++;​ if (i &lt; (* La).length)​ &#123;​ j++;​ k++;​ &#125;​ &#125;​ &#125;​ while (i &lt; (* La).length)​ &#123;​ (* La).elem[count] = (* La).elem[i];​ count++;​ i++;​ &#125;​ (* La).length = count;&#125; ◇2.30⑤ 要求同2.29题。试对单链表编写算法，请释放A表中的无用结点空间。解答答案123456789101112131415161718192021222324252627282930313233343536int DeleteBAndCFromA_Link(LinkList A, LinkList B, LinkList C)&#123; LinkList pa, pb, pc, p;​ if (!A || !B || !C || !A-&gt;next || !B-&gt;next || !C-&gt;next)​ return ERROR;​ pa = A;​ pb = B-&gt;next;​ pc = C-&gt;next;​ p = NULL;​ while (pa || pb || pc)​ &#123;​ if (pb-&gt;data &lt; pc-&gt;data)​ pb = pb-&gt;next;​ else if (pb-&gt;data &gt; pc-&gt;data)​ pc = pc-&gt;next;​ else​ &#123;​ while (pa &amp;&amp; pa-&gt;next-&gt;data &lt; pb-&gt;data)​ pa = pa-&gt;next;​ if (pa-&gt;next-&gt;data == pb-&gt;data)​ &#123;​ p = pa-&gt;next;​ pa-&gt;next = p-&gt;next;​ p-&gt;next = NULL;​ free(p);​ &#125;​ pb = pb-&gt;next;​ pc = pc-&gt;next;​ &#125;​ &#125;​ return OK;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243Status Algo_2_30(LinkList La, LinkList Lb, LinkList Lc)&#123; LinkList pa, pb, pc, pre;​ if (!La || !Lb || !Lc)​ return ERROR;​ pa = La-&gt;next;​ pb = Lb-&gt;next;​ pc = Lc-&gt;next;​ pre = La;​ while (pa &amp;&amp; pb &amp;&amp; pc)​ &#123;​ if (pb-&gt;data &lt; pc-&gt;data)​ pb = pb-&gt;next;​ else if (pb-&gt;data &gt; pc-&gt;data)​ pc = pc-&gt;next;​ else​ &#123;​ while (pa &amp;&amp; pa-&gt;data &lt; pb-&gt;data)​ &#123;​ pre = pa;​ pa = pa-&gt;next;​ &#125;​ while (pa &amp;&amp; pa-&gt;data == pb-&gt;data)​ &#123;​ pre-&gt;next = pa-&gt;next;​ free(pa);​ pa = pre-&gt;next;​ &#125;​ if (pa)​ &#123;​ pb = pb-&gt;next;​ pc = pc-&gt;next;​ &#125;​ &#125;​ &#125;​ return OK;&#125; 2.31② 假设某个单向循环链表的长度大于1，且表中既无头结点也无头指针。已知s为指向链表中某个结点的指针，试编写算法在链表中删除指针s所指结点的前驱结点。解答答案11 2.32② 已知有一个单向循环链表，其每个结点中含三个域：pre，data和next，其中data为数据域，next为指向后继结点的指针域，pre也为指针域，但它的值为空(NULL)，试编写算法将此单向循环链表改为双向循环链表，即使pre称为指向前驱结点的指针域。解答答案11 ◇2.33③ 已知由一个线性链表表示的线性表中含有三类字符的数据元素（如：字母字符、数字字符和其他字符），试编写算法将该线性链表分割为三个循环链表，其中每个循环链表表示的线性表中均只含一类字符。解答答案12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int SplitLinkListByType(LinkList A, LinkList La, LinkList Lb, LinkList Lc)&#123; // 操作条件：链表A中含三类字符；操作结果：将其按字符类型分割成三个循环链表 LinkList p, pa, pb, pc, pre;​ if (!A)​ return ERROR;​ p = A-&gt;next;​ pa = La;​ pb = Lb;​ pc = Lc;​ while (p) // A中还有结点​ &#123;​ if (isalpha(p-&gt;data)) // 如果是字母字符​ &#123;​ pre = pa;​ if (!pa = (LinkList)malloc(sizeof(LNode)))​ return ERROR;​ pre-&gt;next = pa;​ pa-&gt;data = p-&gt;data;​ pa-&gt;next = La-&gt;next; // 循环链表La​ &#125;​ else if (isdigit(p-&gt;data)) // 如果是数字字符​ &#123;​ pre = pb;​ if (!pb = (LinkList)malloc(sizeof(LNode)))​ return ERROR;​ pre-&gt;next = pb;​ pb-&gt;data = p-&gt;data;​ pb-&gt;next = Lb-&gt;next;​ &#125;​ else​ &#123;​ pre = pc;​ if (!pc(LinkList)malloc(sizeof(LNode)))​ return ERROR;​ pre-&gt;next = pc;​ pc-&gt;data = p-&gt;data;​ pc-&gt;next = Lc-&gt;next;​ &#125;​ p = p-&gt;next;​ &#125;​ return OK;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243Status Algo_2_33(LinkList L, LinkList L_char, LinkList L_num, LinkList L_other)&#123; LinkList r, rc, rn, ro, s;​ if (!L)​ return ERROR;​ r = L-&gt;next;​ rc = L_char;​ rn = L_num;​ ro = L_other;​ while (r)​ &#123;​ s = (LinkList)malloc(sizeof(LNode));​ if (!s)​ exit(OVERFLOW);​ s-&gt;data = r-&gt;data;​ if (isalpha(r-&gt;data)) // 结点值为字母​ &#123;​ s-&gt;next = rc-&gt;next;​ rc-&gt;next = s;​ rc = rc-&gt;next;​ &#125;​ else if (isdigit(r-&gt;data)) // 结点值为数字​ &#123;​ s-&gt;next = rn-&gt;next;​ rn-&gt;next = s;​ rn = rn-&gt;next;​ &#125;​ else // 其他​ &#123;​ s-&gt;next = ro-&gt;next;​ ro-&gt;next = s;​ ro = ro-&gt;next;​ &#125;​ r = r-&gt;next;​ &#125;​ return OK;&#125; ☆在2.34至2.36题中，“异或指针双向链表”类型XorLinkedList和指针异或函数XorP定义为：12345678910typedef struct XorNode&#123; char data; struct XorNode LRPtr;&#125;XorNode, *XorPointer; typedef struct&#123; //无头结点的异或指针双向链表 XorPointer Left, Right; //分别指向链表的左端和右端&#125;XorLinkedList; XorPointer XorP(XorPointer p, XorPointer q); //指针异或函数XorP返回指针p和q的异或(XOR)值 (该程序完整答案于题2.36后给出) 2.34④ 假设在算法描述语言中引入指针的二元运算“异或”（用“⊕”表示），若a和b为指针，则a⊕b的运算结果仍为原指针类型，且a⊕(a⊕b)=(a⊕a)⊕b=b;(a⊕b)⊕b=a⊕(b⊕b)=a;则可利用一个指针域来实现双向链表L。链表L中的每个结点只含两个域：data域和LRPtr域，其中LRPtr域存放该结点的左邻与右邻结点指针（不存在时为NULL）的异或。若设指针L.Left指向链表中的最左结点，L.Right指向链表中的最右结点，则可实现从左向右或从右向左遍历此双向链表的操作。试写一算法按任一方向依次输出链表中各元素的值。解答答案没……没太懂题意…… 123456789101112131415161718192021222324int PrintData_LtoR(XorLinkedList XorL)&#123; // 操作条件：异或指针双向链表存在。 操作结果：从左到右依次输出链表中各元素的值 XorPointer p1, p2, p;​ if (!XorL.Left) // 异或指针双向链表不存在​ return ERROR;​ p1 = XorL.Left;​ p2 = p1-&gt;LRPtr;​ while (p1 != XorL.Right)​ &#123;​ cout &lt;&lt; p1-&gt;data &lt;&lt; " ";​ p = p2;​ p2 = XorP(p2, p1); // p2前移​ p1 = p; // p1前移​ &#125;​ cout &lt;&lt; p1-&gt;data &lt;&lt; endl;​ return OK;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 输出L，mark表示方向，0为顺序，1为逆序// 借助Prior_Next_Ptr_XorL函数遍历链表Status Algo_2_34_1(Xor L, int mark)&#123; XorPointer cur;​ if (mark != 1 &amp;&amp; mark != 0)​ return ERROR;​ if (!L || !L-&gt;Left) // 链表不存在或链表为空则无法输出​ return ERROR;​ if (mark == 0)​ &#123;​ cur = L-&gt;Left;​ do​ &#123;​ printf("%c", cur-&gt;data);​ cur = Prior_Next_Ptr_XorL(L, cur, !mark);​ &#125;while (cur);​ &#125;​ if (mark == 1)​ &#123;​ cur = L-&gt;Right;​ do​ &#123;​ printf("%c", cur-&gt;data);​ cur = Prior_Next_Ptr_XorL(L, cur, !mark);​ &#125;while (cur);​ &#125;​ return OK;&#125;// 不借助前驱_后继函数遍历链表Status Algo_2_34_2(Xor L, int mark) // i=0代表从左向右输出，1代表从右向左输出&#123; XorPointer p_1, p_m, p_r;​ if (mark != 1 &amp;&amp; mark != 0)​ return ERROR;​ if (!L || !L-&gt;Left) // 链表不存在或链表为空则无法输出​ return ERROR;​ if (mark == 0) // 从左向右​ &#123;​ p_1 = NULL;​ p_m = L-&gt;Left;​ while (p_m) // p_m为空时说明已输出完毕​ &#123;​ printf("%c", p_m-&gt;data);​ p_r = XorP_XorL(p_1, p_m-&gt;LRPtr); // 计算右侧第一个结点地址​ p_1 = p_m; // 指针不断推进​ p_m = p_r;​ &#125;​ &#125;​ if (mark == 1)​ &#123;​ p_m = L-&gt;Right;​ p_r = NULL;​ while (p_m)​ &#123;​ printf("%c", p_m-&gt;data);​ p_1 = XorP_XorL(p_m-&gt;LRPtr, p_r);​ p_r = p_m;​ p_m = p_1;​ &#125;​ &#125;​ return OK;&#125; 2.35④ 采用2.34题所述的存储结构，写出在第i个结点之前插入一个结点的算法。解答答案12345678910111213141516171819202122232425262728293031323334353637383940int InsertXorNode(XorLinkedList XorL, XorNode n, int i)&#123; // 操作条件：链表XorL存在。操作结果：在第i个结点前插入结点n XorPointer p1, p2, p; int count = 2;​ if (!XorL || !XorL.Left)​ return ERROR; // 表XorL不存在或为空​ if (i &lt;= 0)​ return ERROR;​ p1 = XorL.left;​ p2 = p1-&gt;LRPtr;​ if (i == 1)​ &#123;​ n-&gt;LRPtr = p1;​ p1-&gt;LRPtr = XorP(n, p2);​ p1 = n;​ &#125;​ else // i &gt; 1​ &#123;​ for (; count &lt; i; count++)​ &#123;​ p = p2;​ p2 = XorP(p2, p1);​ p1 = p;​ if (p2 = NULL) // 超出链表上限​ return ERROR;​ &#125;​ n-&gt;LRPtr = XorP(p1, p2);​ p1-&gt;LRPtr = XorP(XorP(p1, p2), n);​ p2-&gt;LRPtr = XorP(n, XorP(p2, p1));​ &#125;​ return OK;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051Status Algo_2_35(Xor L, int i, XElemType e)&#123; XorPointer s, i_pre_pre, i_pre, i_cur, i_suc;​ if (!L) // L必须存在​ return ERROR;​ if (i &lt; 1 || i &gt; Length_XorL(L) + 1) // i限制在正确的范围内​ return ERROR;​ s = (XorPointer)malloc(sizeof(XorNode));​ if (!s)​ return OVERFLOW;​ s-&gt;data = e;​ i_cur = GetElemPtr_XorL(L, i); // 指向第i个结点​ i_pre = GetElemPtr_XorL(L, i - 1); // 指向第i-1个结点​ i_pre_pre = GetElemPtr_XorL(L, i - 2); // 指向第i-2个结点​ if (!i_cur) // 第i个结点不存在​ &#123;​ if (!i_pre) // 链表为空，插入为首结点​ &#123;​ s-&gt;LRPtr = NULL;​ L-&gt;Left = s;​ &#125;​ else // 链表不空，插入为尾结点​ &#123;​ s-&gt;LRPtr = i_pre;​ i_pre-&gt;LRPtr = XorP_XorL(i_pre_pre, s);​ &#125;​ L-&gt;Right = s;​ &#125;​ else // 第i个结点存在​ &#123;​ i_suc = XorP_XorL(i_pre, i_cur-&gt;LRPtr); // 指向第i+1个结点​ s-&gt;LRPtr = XorP_XorL(i_pre, i_cur); // 设定s的后继指针​ i_cur-&gt;LRPtr = XorP_XorL(s, i_suc); // 当前结点的后继指针也要改变​ if (!i_pre) // 链表不空，插入为首结点​ L-&gt;Left = s;​ else​ i_pre-&gt;LRPtr = XorP_XorL(i_pre_pre, s);​ &#125;​ return OK;&#125; 2.36④ 采用2.34题所述的存储结构，写出删除第i个结点的算法。解答答案12345678910111213141516171819202122232425262728293031323334353637383940int DeleteXorNode(XorLinkedList XorL, int i)&#123; // 操作条件：异或指针双向链表XorL已存在。操作结果：删除第i个结点 XorPointer p1, p2, p; int count = 2;​ if (!XorL || !XorL.Left) // 表不存在或为空​ return ERROR;​ if (i &lt; 1) // i 数值错误​ return ERROR;​ p1 = XorL.Left;​ p2 = p1-&gt;LRPtr;​ if (i == 1)​ &#123;​ p2-&gt;LRPtr = XorP(p2, p1);​ XorL.Left = p2;​ free(p1);​ &#125;​ else​ &#123;​ for (; count &lt; i; count++)​ &#123; ​ p = p1;​ p2 = XorP(p2, p1); // p2 p1 向前推进​ p1 = XorP(p1, p2);​ if (p2 = NULL) // i值超出表长度​ return ERROR;​ &#125;​ p2-&gt;LRPtr = XorP(p2, p); // 更新p2指针​ p-&gt;LRPtr = XorP(XorP(p, p1), p2); // 更新p指针​ free(p1);​ &#125;​ return OK;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 删除第i个结点，并用e接受结点中元素值Status Algo_2_36(Xor L, int i, char *e)&#123; XorPointer i_pre_pre, i_pre, i_cur, i_suc, i_suc_suc;​ if (i &lt; 1 || i &gt; Length_XorL(L))​ return ERROR;​ if (!L || !L-&gt;Left)​ return ERROR;​ i_cur = GetElemPtr_XorL(L, i); // 指向第i个结点​ *e = i_cur-&gt;data;​ i_pre = GetElemPtr_XorL(L, i - 1); // 指向第i-1个结点​ i_suc = XorP_XorL(i_pre, i_cur-&gt;LRPtr); // 指向第i+1个结点​ if (!i_suc) // 删除尾结点​ &#123;​ L-&gt;Right = i_pre;​ if (!i_pre) // 只有一个结点的情况​ L-&gt;Left = NULL;​ else i_pre-&gt;LRPtr = XorP_XorL(i_pre-&gt;LRPtr, i_cur);​ &#125;​ else​ &#123;​ if (!i_pre) // 删除首结点​ &#123;​ L-&gt;Left = i_suc;​ i_suc-&gt;LRPtr = XorP_XorL(i_cur, i_suc-&gt;LRPtr);​ &#125;​ else​ &#123;​ i_pre_pre = XorP_XorL(i_pre-&gt;LRPtr, i_cur); // 指向第i-2个结点​ i_suc_suc = XorP_XorL(i_cur, i_suc-&gt;LRPtr); // 指向第i+2个结点​ i_pre-&gt;LRPtr = XorP_XorL(i_pre_pre, i_suc);​ i_suc-&gt;LRPtr = XorP_XorL(i_pre, i_suc_suc);​ &#125;​ &#125;​ free(i_cur);​ i_cur = NULL;​ return OK;&#125; 异或指针双向链表 (来源:康建伟-博客园https://www.cnblogs.com/kangjianwei101/p/5222655.html) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; // 提供malloc、realloc、free、exit原型#define OVERFLOW -2 //堆栈上溢#define OK 1 //通过#define ERROR 0 //错误/* 类型定义 */typedef int Status;typedef char XElemType;typedef struct XorNode // 异或指针链表结点结构&#123; XElemType data; struct XorNode *LRPtr;&#125;XorNode;typedef XorNode* XorPointer; // 指向结点结构的指针typedef struct &#123; XorPointer Left; // 分别指向链表的最左端（头指针）和最右端（尾指针） XorPointer Right;&#125;XorLinkedList;typedef XorLinkedList* Xor;/* 异或指针链表函数原型 */Status Algo_2_34_1(Xor L, int mark);Status Algo_2_34_2(Xor L, int mark);Status Algo_2_35(Xor L, int i, XElemType e);Status Algo_2_36(Xor L, int i, char *e);XorPointer XorP_XorL(XorPointer p, XorPointer q);Status Init_XorL(Xor *L);Status Create_XorL(Xor L, int n, XElemType Data[]);XorPointer Prior_Next_Ptr_XorL(Xor L, XorPointer cur, int mark);int Length_XorL(Xor L);XorPointer GetElemPtr_XorL(Xor L, int i);int main(int argc, char const *argv[])&#123; Xor L; XElemType e; int n = 9; XElemType *data = "123456789"; Init_XorL(&amp;L); // 先初始化 Create_XorL(L, n, data); printf("---题 2.34 验证...---\n"); printf("方法一：\n"); printf("顺序输出L = "); Algo_2_34_1(L, 0); printf("\n"); printf("逆序输出L = "); Algo_2_34_1(L, 1); printf("\n\n"); printf("方法二：\n"); printf("顺序输出L = "); Algo_2_34_2(L, 0); printf("\n"); printf("逆序输出L = "); Algo_2_34_2(L, 1); printf("\n\n"); printf("---题 2.35 验证...---\n"); Algo_2_35(L, 5, '*'); printf("插入‘*’为L的第5个结点后顺序输出...\n"); Algo_2_34_2(L, 0); printf("\n\n"); printf("---题 2.36 验证...---\n"); Algo_2_36(L, 5, &amp;e); printf("删除L的第5个结点‘%c’后逆序输出...\n", e); Algo_2_34_2(L, 1); printf("\n\n"); return 0;&#125;/*------------------------------------| (01)指针异或函数，返回指针p和q的异或值 | ------------------------------------*/XorPointer XorP_XorL(XorPointer p, XorPointer q)&#123; unsigned long long x, y, z; x = (unsigned long long)p; y = (unsigned long long)q; z = x ^ y; // 求异或 return (XorPointer)z;&#125;/*-----------------------| (02)初始化异或指针链表L | ----------------------*/Status Init_XorL(Xor *L)&#123; *L = (Xor)malloc(sizeof(XorLinkedList)); if (!(*L)) exit(OVERFLOW); (*L)-&gt;Left = NULL; (*L)-&gt;Right = NULL; return OK;&#125;/*---------------------| (03)创建异或指针链表L | --------------------*/Status Create_XorL(Xor L, int n, XElemType Data[])&#123; int i; XorPointer pre_1, pre_m, pre_r; pre_1 = pre_m = NULL; for (i = 1; i &lt;= n; i++) &#123; pre_r = (XorPointer)malloc(sizeof(XorNode)); if (!pre_r) exit(OVERFLOW); pre_r-&gt;data = Data[i - 1]; if (i == 1) // 左指针（创建首结点时设立） L-&gt;Left = pre_r; if (pre_m) // pre_m不为空时执行，从创立第二个结点时执行 pre_m-&gt;LRPtr = XorP_XorL(pre_1, pre_r); L-&gt;Right = pre_r; // 右指针 pre_r-&gt;LRPtr = XorP_XorL(pre_m, NULL); pre_1 = pre_m; pre_m = pre_r; &#125; return OK;&#125;/*------------------------------------------------| (04)获取当前结点(cur)的前驱(mark=0)或后继(mark=1) | ------------------------------------------------*/XorPointer Prior_Next_Ptr_XorL(Xor L, XorPointer cur, int mark)&#123; XorPointer p_1, p_m, p_r; if (mark != 1 &amp;&amp; mark != 0) return NULL; if (!L || !L-&gt;Left || !cur) // 链表不存在或链表为空或cur为空则无法求地址 return NULL; if (mark == 1) // 求后继，从左向右 &#123; p_1 = NULL; p_m = L-&gt;Left; while (p_m != cur) &#123; p_r = XorP_XorL(p_1, p_m-&gt;LRPtr); // 计算右侧第一个结点地址 p_1 = p_m; // 指针不断向右推进 p_m = p_r; &#125; p_r = XorP_XorL(p_1, p_m-&gt;LRPtr); return p_r; &#125; if (mark == 0) // 求前驱，从右向左 &#123; p_m = L-&gt;Right; p_r = NULL; while (p_m != cur) &#123; p_1 = XorP_XorL(p_m-&gt;LRPtr, p_r); // 计算左侧第一个结点地址 p_r = p_m; // 指针不断向左推进 p_m = p_1; &#125; p_1 = XorP_XorL(p_m-&gt;LRPtr, p_r); return p_1; &#125;&#125;/*--------------| (05)获取L长度 | -------------*/int Length_XorL(Xor L)&#123; int count; XorPointer p, pre, psuc; if (!L) exit(OVERFLOW); // 链表不存在则退出 count = 0; pre = NULL; p = L-&gt;Left; // 从左向右遍历 while (p) &#123; count++; psuc = XorP_XorL(pre, p-&gt;LRPtr); pre = p; p = psuc; &#125; return count;&#125;/*--------------------------| (06)返回指向第i个结点的指针 | --------------------------*/XorPointer GetElemPtr_XorL(Xor L, int i) // i为元素位序&#123; int count; XorPointer p, pre, psuc; if (!L || !L-&gt;Left) // 链表不存在或链表为空无法求地址 return ERROR; if (i &lt; 1) return ERROR; count = 1; pre = NULL; p = L-&gt;Left; while (count &lt; i &amp;&amp; p) &#123; psuc = XorP_XorL(pre, p-&gt;LRPtr); pre = p; p = psuc; count++; &#125; return p;&#125;/*-----------------------------| (07-1)输出L，mark表示输出方向 | ----------------------------*//* 方法1：借助Prior_Next_Ptr_XorL函数遍历链表 */Status Algo_2_34_1(Xor L, int mark)&#123; XorPointer cur; if (mark != 1 &amp;&amp; mark != 0) return ERROR; if (!L || !L-&gt;Left) // 链表不存在或链表为空则无法输出 return ERROR; if (mark == 0) &#123; cur = L-&gt;Left; do &#123; printf("%c", cur-&gt;data); cur = Prior_Next_Ptr_XorL(L, cur, !mark); &#125;while (cur); &#125; if (mark == 1) &#123; cur = L-&gt;Right; do &#123; printf("%c", cur-&gt;data); cur = Prior_Next_Ptr_XorL(L, cur, !mark); &#125;while (cur); &#125; return OK;&#125;/*-----------------------------| (07-2)输出L，mark表示输出方向 | ----------------------------*//* 方法2：不借助前驱_后继函数遍历链表 */Status Algo_2_34_2(Xor L, int mark) // i=0代表从左向右输出，1代表从右向左输出&#123; XorPointer p_1, p_m, p_r; if (mark != 1 &amp;&amp; mark != 0) return ERROR; if (!L || !L-&gt;Left) // 链表不存在或链表为空则无法输出 return ERROR; if (mark == 0) // 从左向右 &#123; p_1 = NULL; p_m = L-&gt;Left; while (p_m) // p_m为空时说明已输出完毕 &#123; printf("%c", p_m-&gt;data); p_r = XorP_XorL(p_1, p_m-&gt;LRPtr); // 计算右侧第一个结点地址 p_1 = p_m; // 指针不断推进 p_m = p_r; &#125; &#125; if (mark == 1) &#123; p_m = L-&gt;Right; p_r = NULL; while (p_m) &#123; printf("%c", p_m-&gt;data); p_1 = XorP_XorL(p_m-&gt;LRPtr, p_r); p_r = p_m; p_m = p_1; &#125; &#125; return OK;&#125;/*-----------------------------| (08)将元素e插入到第i个结点之前 | ----------------------------*/Status Algo_2_35(Xor L, int i, XElemType e)&#123; XorPointer s, i_pre_pre, i_pre, i_cur, i_suc; if (!L) // L必须存在 return ERROR; if (i &lt; 1 || i &gt; Length_XorL(L) + 1) // i限制在正确的范围内 return ERROR; s = (XorPointer)malloc(sizeof(XorNode)); if (!s) return OVERFLOW; s-&gt;data = e; i_cur = GetElemPtr_XorL(L, i); // 指向第i个结点 i_pre = GetElemPtr_XorL(L, i - 1); // 指向第i-1个结点 i_pre_pre = GetElemPtr_XorL(L, i - 2); // 指向第i-2个结点 if (!i_cur) // 第i个结点不存在 &#123; if (!i_pre) // 链表为空，插入为首结点 &#123; s-&gt;LRPtr = NULL; L-&gt;Left = s; &#125; else // 链表不空，插入为尾结点 &#123; s-&gt;LRPtr = i_pre; i_pre-&gt;LRPtr = XorP_XorL(i_pre_pre, s); &#125; L-&gt;Right = s; &#125; else // 第i个结点存在 &#123; i_suc = XorP_XorL(i_pre, i_cur-&gt;LRPtr); // 指向第i+1个结点 s-&gt;LRPtr = XorP_XorL(i_pre, i_cur); // 设定s的后继指针 i_cur-&gt;LRPtr = XorP_XorL(s, i_suc); // 当前结点的后继指针也要改变 if (!i_pre) // 链表不空，插入为首结点 L-&gt;Left = s; else i_pre-&gt;LRPtr = XorP_XorL(i_pre_pre, s); &#125; return OK;&#125;/*--------------------------------------| (09)删除第i个结点，并用e接受结点中元素值 | --------------------------------------*/Status Algo_2_36(Xor L, int i, char *e)&#123; XorPointer i_pre_pre, i_pre, i_cur, i_suc, i_suc_suc; if (i &lt; 1 || i &gt; Length_XorL(L)) return ERROR; if (!L || !L-&gt;Left) return ERROR; i_cur = GetElemPtr_XorL(L, i); // 指向第i个结点 *e = i_cur-&gt;data; i_pre = GetElemPtr_XorL(L, i - 1); // 指向第i-1个结点 i_suc = XorP_XorL(i_pre, i_cur-&gt;LRPtr); // 指向第i+1个结点 if (!i_suc) // 删除尾结点 &#123; L-&gt;Right = i_pre; if (!i_pre) // 只有一个结点的情况 L-&gt;Left = NULL; else i_pre-&gt;LRPtr = XorP_XorL(i_pre-&gt;LRPtr, i_cur); &#125; else &#123; if (!i_pre) // 删除首结点 &#123; L-&gt;Left = i_suc; i_suc-&gt;LRPtr = XorP_XorL(i_cur, i_suc-&gt;LRPtr); &#125; else &#123; i_pre_pre = XorP_XorL(i_pre-&gt;LRPtr, i_cur); // 指向第i-2个结点 i_suc_suc = XorP_XorL(i_cur, i_suc-&gt;LRPtr); // 指向第i+2个结点 i_pre-&gt;LRPtr = XorP_XorL(i_pre_pre, i_suc); i_suc-&gt;LRPtr = XorP_XorL(i_pre, i_suc_suc); &#125; &#125; free(i_cur); i_cur = NULL; return OK;&#125; 2.37④设以带头结点的双向循环链表表示的线性表L=(a1, a2, …, an)，试写一时间复杂度为O(n)的算法，将L改造为L=(a1, a3, …, an, …, a4, a2)。解答答案12345678910111213141516171819202122232425262728293031323334353637383940414243int OddEven_DuL(DuLinkList &amp;L)&#123; // 操作条件：双向链表L存在。 // 操作结果：将双向链表L=(a1, a2, ..., an)改造为L=(a1, a3, ..., an, ..., a4, a2) DuLinkList p1, Lo, Le; int i = 1; int count_o = 1; int count_e = 1;​ if (!L || !L-&gt;next)​ return ERROR;​ p1 = L-&gt;next;​ InitList_DuL(Lo);​ InitList_DuL(Le);​ for (; i &lt;= Length_DuL(L); i++) // 遍历L，制作奇数位链表Lo和偶数位链表Le​ &#123;​ if (i%2) // 奇数位​ &#123;​ LinkInsert_DuL(Lo, count_o, p1-&gt;data);​ count_o++;​ &#125;​ if (!i%2) // 偶数位​ &#123;​ LinkInsert_DuL(Le, count_e, p1-&gt;data);​ count_e++;​ &#125;​ p1 = p1-&gt;next;​ &#125;​ Lo-&gt;next-&gt;prior-&gt;next = Le-&gt;next-&gt;prior; // Lo 和 Le 的末位相连​ Le-&gt;next-&gt;prior-&gt;next = Lo-&gt;next-&gt;prior;​ Lo-&gt;next-&gt;prior = Le-&gt;next; // Lo 和 Le 的首位相连​ Le-&gt;next-&gt;next = Lo-&gt;next;​ p1 = L;​ L = Lo;​ DestroyList_DuL(p1); // 销毁原链表​ return OK;&#125;12345678910111213141516171819202122232425262728293031323334Status Algo_2_37(DuLinkList L)&#123; DuLinkList head, tail, p;​ if (!L)​ return ERROR;​ head = L-&gt;next; // 向右推进​ tail = L-&gt;prior; // 固定不动​ while (head != tail)​ &#123;​ if (head-&gt;next != tail)​ &#123;​ p = head-&gt;next; // 摘下此结点​ p-&gt;next-&gt;prior = head;​ head-&gt;next = p-&gt;next;​ p-&gt;next - tail-&gt;next;​ p-&gt;prior = tail;​ tail-&gt;next-&gt;prior = p;​ tail-&gt;next = p;​ head = head-&gt;next;​ &#125;​ else​ break;​ &#125;​ return OK;&#125; ◇2.38④设有一个双向循环链表，每个结点中除有pre，data和next三个域外，还增设了一个访问频度域freq。在链表被起用之前，频度域freq的值均初始化为零，而每当对链表进行一次LOCATE(L, x)的操作后，被访问的结点（即元素值等于x的结点）中的频度域freq的值便增1，同时调整链表中结点之间的次序，使其按访问频度非递增的次序顺序排列，以便始终保持被频繁访问的结点总是靠近表头结点，试编写符合上述要求的LOCATE操作的算法。解答答案1234567891011121314151617181920212223242526272829303132333435363738int LOCATE(DuLinkList &amp;L, ElemType x)&#123; // 操作条件：L存在，操作结果：被访问节点freq+1，并调整结点次序按freq非递增排列 int p, q; ElemType a;​ if (!L ||!L-&gt;next)​ return ERROR;​ p = L-&gt;next;​ while (p-&gt;data != x)​ &#123;​ if (p == L-&gt;prior) // 遍历到最后也没找到x​ return ERROR;​ p = p-&gt;next;​ &#125;​ p-&gt;freq++;​ q = p;​ while (q-&gt;prior-&gt;freq &lt; p-&gt;freq)​ &#123;​ q = q-&gt;prior;​ if (q == L-&gt;next) // 遍历到首结点也没找到比p-&gt;frep大的​ break;​ &#125;​ a = p-&gt;data; // 交换p和q的data与freq​ p-&gt;data = q-&gt;data;​ q-&gt;data = a;​ p-&gt;freq--;​ q-&gt;freq++;​ return OK;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263DuLinkList Algo_2_38(DULinkList * L, LElemType_DC e)&#123; DuLinkList p, pre; int i;​ if (!(* L)) // 链表不存在​ return NULL;​ // 查找结点e的所在​ for (p = * L; p; p = p-&gt;next)​ &#123;​ // 找到了e​ if (p-&gt;data == e)​ break;​ // 没找到，但到了终点​ if (p-&gt;next == p)​ &#123;​ p = NULL;​ break;​ &#125;​ &#125;​ if (p != NULL) // 找到了与e相等的结点​ &#123;​ p-&gt;freq++; // 访问频度递增​ if (p != *L) // p不在首位的话，需要考虑重新摆放​ &#123;​ for (pre = p-&gt;prior; pre-&gt;freq &lt; p-&gt;freq; pre = pre-&gt;prior)​ &#123;​ // 已经找到头，但没有找到比p的频度更大的结点​ if (pre == *L)​ &#123;​ pre == NULL;​ break;​ &#125;​ &#125;​ p-&gt;next-&gt;prior = p-&gt;prior; // 摘下结点p​ p-&gt;prior-&gt;next = p-&gt;next;​ if (pre == NULL) // p作为新的链表头部​ &#123;​ p-&gt;prior = (* L)-&gt;prior;​ p-&gt;prior-&gt;next = p;​ p-&gt;next = * L;​ (* L)-&gt;prior = p;​ * L = p;​ &#125;​ else // p放到pre之后​ &#123;​ p-&gt;prior = pre;​ p-&gt;next = pre-&gt;next;​ p-&gt;next-&gt;prior = p;​ pre-&gt;next = p;​ &#125;​ &#125;​ &#125;​ return p; // 返回当前结点指针&#125; ☆在2.39至2.40题中，稀疏多项式采用的顺序存储结构SqPoly定义为：12345678910typedef struct&#123; int coef; int exp;&#125;PolyTerm;typedef struct&#123; //多项式的顺序存储结构 PolyTerm *data; int last;&#125;SqPoly; ◇2.39③已知稀疏多项式$P_n(X) = c_1x^{e_1}+c_2x^{e_2}+…+c_mx^{e_m}$，其中n=em&gt;em-1&gt;…&gt;e1≥0，ci≠0(i=1,2,…,m),m≥1。试采用存储量同多项式项数m成正比的顺序存储结构，编写求Pn(x0)的算法(x0为给定值)，并分析你的算法的时间复杂度。解答答案12345678910111213int PnXValue(SqPoly &amp;L_SqPoly, int x0)&#123; // 操作条件：稀疏多项式存在。操作结果：求Pn(x0)的值 int Pn = 0;​ if (!L_SqPoly || L_SqPoly.last == 0) // L_SqPoly 不存在或为空​ return ERROR;​ for (int i = 0; i &lt; L_SqPoly.last; i++)​ Pn += L_SqPoly.data[i].coef * pow(x0, L_SqPoly.data[i].exp);​ return Pn;&#125; 时间复杂度：O(L_SqPoly.last)123456789int Algo_2_39(SqPoly P, int x)&#123; int i, sum;​ for (i = 0, sum = 0; i &lt; P.last; i++)​ sum += P.data[i].coef * (int)(pow(x, P.data[i].exp));return sum;&#125; 时间复杂度为O(n)，只与顺序表长度有关。 2.40③采用2.39题给定的条件和存储结构，编写求P(x)=Pn1&lt;/sub&gt;(x)-Pn2&lt;/sub&gt;(x)的算法，将结果多项式存放在新辟的空间中，并分析你的算法的时间复杂度。解答答案12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667SqPoly PolyAddPoly(SqPoly &amp;L_SqPoly1, SqPoly &amp;L_SqPoly2, SqPoly L_SqPolySum)&#123; // 操作条件：两结构存在。操作结果：将两多项式相加并将结果存放在新辟的空间中 int last1, last2, lastSum;​ L_SqPolySum.last = 0; //初始化​ last1 = last2 = lastSum = 0;​ while (last1 &lt; L_SqPoly1.last &amp;&amp; last2 &lt; L_SqPoly2.last)​ &#123;​ if (L_SqPoly1.data[last1].exp = L_SqPoly2.data[last2].exp) // 指数相等，分配P(x)空间，存入两项的差​ &#123;​ if ((L_SqPoly1.data[last1].coef - L_SqPoly2.data[last2].coef) != 0)​ &#123;​ L_SqPolySum.last++;​ L_SqPolySum.data = (PolyTerm * )realloc(L_SqPolySum.last * sizeof(PolyTerm));​ L_SqPolySum.data[lastSum].coef = L_SqPoly1.data[last1].coef - L_SqPoly2.data[last2].coef;​ L_SqPolySum.data[lastSum].exp = L_SqPoly1.data[last1].exp;​ lastSum++;​ &#125;​ last1++;​ last2++;​ &#125;​ else if (L_SqPoly1.data[last1].exp &lt; L_SqPoly2.data[last2].exp) // P1(x)指数小，直接存入P(x)​ &#123;​ L_SqPolySum.last++;​ L_SqPolySum.data = (PolyTerm * )realloc(L_SqPolySum.last * sizeof(PolyTerm));​ L_SqPolySum.data[lastSum].coef = L_SqPoly1.data[last1].coef;​ L_SqPolySum.data[lastSum].exp = L_SqPoly1.data[last1].exp;​ lastSum++;​ last1++;​ &#125;​ else if (L_SqPoly1.data[last1].exp &gt; L_SqPoly2.data[last2].exp) //P2(x)指数小，取负数存入P(x)​ &#123;​ L_SqPolySum.last++;​ L_SqPolySum.data = (PolyTerm * )realloc(L_SqPolySum.last * sizeof(PolyTerm));​ L_SqPolySum.data[lastSum].coef = -L_SqPoly1.data[last2].coef;​ L_SqPolySum.data[lastSum].exp = L_SqPoly1.data[last2].exp;​ lastSum++;​ last2++;​ &#125;​ &#125;​ while (last1 &lt; L_SqPoly1.last) // P1(x) 还有剩余​ &#123;​ L_SqPolySum.last++;​ L_SqPolySum.data = (PolyTerm * )realloc(L_SqPolySum.last * sizeof(PolyTerm));​ L_SqPolySum.data[lastSum].coef = L_SqPoly1.data[last1].coef;​ L_SqPolySum.data[lastSum].exp = L_SqPoly1.data[last1].exp;​ lastSum++;​ last1++;​ &#125;​ while (last2 &lt; L_SqPoly2.last) // P2(x) 还有剩余​ &#123;​ L_SqPolySum.last++;​ L_SqPolySum.data = (PolyTerm * )realloc(L_SqPolySum.last * sizeof(PolyTerm));​ L_SqPolySum.data[lastSum].coef = -L_SqPoly1.data[last2].coef;​ L_SqPolySum.data[lastSum].exp = L_SqPoly1.data[last2].exp;​ lastSum++;​ last2++;​ &#125;​ return L_SqPolySum;&#125; 时间复杂度：O(L_SqPoly1.last + L_SqPoly2.last)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960Status Algo_2_40(SqPoly Pa, SqPoly Pb, SqPoly *Pc)&#123; int i, j, k, sum;​ (*Pc).data = (PolyTerm *)malloc((Pa.last+Pb.last) * sizeof(PolyTerm));​ if (!(*Pc).data)​ exit(OVERFLOW);​ i = j = k = 0;​ while (i &lt; Pa.last &amp;&amp; j &lt; Pb.last)​ &#123;​ if (Pa.data[i].exp &lt; Pb.data[j].exp)​ &#123;​ (* Pc).data[k++] = pa.data[i];​ i++;​ &#125;​ else if (Pa.data[i].exp &gt; Pb.data[j].exp)​ &#123;​ (* Pc).data[k].coef = -Pb.data[j].coef; // 符号改变​ (* Pc).data[k].exp = Pb.data[j].exp;​ k++;​ j++;​ &#125;​ else​ &#123;​ sum = Pa.data[i].coef - Pb.data[j].coef;​ if (sum)​ &#123;​ (* pc).data[k].coef = sum;​ (* Pc).data[k].exp = Pa.data[i].exp;​ k++;​ &#125;​ i++;​ j++;​ &#125;​ &#125;​ while (i &lt; Pa.last) // Pa 未扫描完​ &#123;​ (* Pc).data[k++] = Pa.data[i];​ i++;​ &#125;​ while (j &lt; Pb.last) // Pb 未扫描完​ &#123;​ (* Pc).data[k].coef = -Pb.data[j].coef; // 符号改变​ (* Pc).data[k].exp = Pb.data[j].exp;​ k++;​ j++;​ &#125;​ (* Pc).last = k;​ return OK;&#125; 由于要遍历p1和p2表，故时间复杂度为O(n1+n2)。 ☆在2.41至2.42题中，稀疏多项式采用的循环链表存储结构LinkedPoly定义为：123456typedef struct PolyNode&#123; PolyTerm data; struct PolyNode *next;&#125;PolyNode, *PolyLink;typedef PolyLink LinkedPoly; ◇2.41②试以循环链表作稀疏多项式的存储结构，编写求其导函数的算法，要求利用原多项式中的结点空间存放其导函数（多项式），同时释放所有无用（被删）结点。解答答案11 2.42②试编写算法，将一个用循环链表表示的稀疏多项式分解成两个多项式，使这两个多项式中各自仅含奇次项或偶次项，并要求利用原链表中的结点空间构成这两个链表。解答答案11]]></content>
      <categories>
        <category>习题</category>
      </categories>
      <tags>
        <tag>习题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络(第7版)谢希仁-第二章物理层]]></title>
    <url>%2F2019%2F08%2F20%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC7%E7%89%88-%E8%B0%A2%E5%B8%8C%E4%BB%81-%E7%AC%AC%E4%BA%8C%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[本章重要内容： 物理层的任务。 几种常用的信道复用技术。 几种常用的宽带接入技术，主要是ADSL和FTTx。 —-2.1 物理层的基本概念用于物理层的协议也常称为物理层规程(procedure)。 将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性： 机械特性。 指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置，等。平时常见的各种规格的接插件都有严格的标准化规定。 电气特性。 指明在接口电缆的各条线上出现的电压范围。 功能特性。 指明某条线上出现的某一电平的电压意义。 过程特性。 指明对于不同功能的各种可能事件的出现顺序。 数据在计算机内部多采用并行传输方式，但在通信线路(传输媒体)上一般都是串行传输(考虑经济)，即逐个比特按时间顺序传输。 具体的物理层协议种类较多。原因：物理连接的方式(点对点，多点连接，广播连接)很多，传输媒体的种类(架空明线，双绞线，对称电缆，同轴电缆，光缆，无线信道等)也很多。 2.2 数据通信的基础知识2.2.1 数据通信系统的模型一个数据通信系统可划分为三大部分，即源系统(或发送端、发送方)、传输系统(或传输网络)和目的系统(或接收端、接收方)。如图所示。 其中，源系统一般包括两个部分： 源点(source) 源点设备要传输的数据。源点又称为源站或信源。 发送器 通常源点生成的数字比特流要通过发送器编码后才能够在传输系统中进行传输。典型的发送器就是调制器。 目的系统也包括两个部分： 接收器 接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。典型的接收器就是调解器。 终点(destination) 终点设备从接收器获取传送来的数字比特流，然后把信息输出。终点又称为目的站或信宿。 通信的目的是传送消息(message)。 数据(data)是传送消息的实体。数据是使用特定方式表示的信息。 信号(signal)是数据的电气或电磁的表现。 信号可分为以下两大类： 模拟信号(或连续信号) 代表消息的参数的取值是连续的。在图2.1-1中表示为用户家中的调制解调器到电话端局之间的用户线上的信号。 数字信号(或离散信号) 代表消息的参数的取值是离散的。在图2.1-1中表示为用户家中的计算机到调制解调器之间，和电话网中继线上的信号。 (在使用时间域(时域)的波形表示数字信号时，代表不同离散数值的基本波形就称为码元.)(一个码元所携带的信息量是不固定的，由调制方式和编码方式决定.) 2.2.2 有关信道的几个基本概念信道≠电路。一条通信电路往往包含一条发送信道和一条接收信道。 信道(channel)一般用来表示向某一个方向发送信息的媒体。 从通信的双方信息交互的方式来分，有以下三种基本方式： 单向通信 又称单工通信，即只有一个方向的通信而没有反方向的交互。eg无线电广播，有线电广播，电视广播。 双向交替通信 又称半双工通信，即通信的双方都可以发送信息，但不能双方同时发送。 双向同时通信 又称全双工通信，即通信双方可以同时发送和接受信息。 (常用语：”单工”也常被用作表示”双向交替通信”，例如”单工电台”。) 基带信号(即基本频带信号)即为来自信源的信号。其往往包含有较多的低频成分，甚至直流成分。但许多信道不能传输这两种成分，故须对基带信号进行调制(modulation)。 调制分为以下两大类： 基带调制 只对基带信号的波形进行变换，是它能与信道特性相适应，但变换后仍是基带信号。该方式是把数字信号转换为另一种形式的数字信号，因此该过程常被称为编码(coding)。 带通调制 使用载波(carrier)进行调制，将基带信号的频率范围搬移到较高的频段，并转换为模拟信号，在模拟信道中传输。调制后的信号称为带通信号(仅在一段频率范围内能通过信道)。 常用编码方式： 不归零制 正电平代表1，负电平代表0。 归零制 正脉冲代表1，负脉冲代表0。 曼彻斯特编码 位周期中心的向上跳变代表0，向下跳变代表1。 查分曼彻斯特编码 在每一位的中心处始终都有跳变，位开始边界有跳变代表0，没有跳变代表1。 曼彻斯特(Manchester)编码产生的信号频率比不归零制高。 不归零制不能从信号波形本身提取信号时钟频率(即没有自同步能力)，曼彻斯特编码具有自同步能力。 基本的带通调制方法： 调幅(AM) 即载波的振幅随基带数字信号而变化。eg，0或1分别对应于无载波或有载波输出。 调频(FM) 即载波的频率随基带数字信号而变化。eg，0或1分别对应于频率f1或f2。 调相(PM) 即载波的初始相位随基带数字信号而变化。eg，0或1分别对应于相位0度或180度。 (正交振幅调制QAM(Quadrature Amplitude Modulation)：技术上更为复杂的多元制的振幅相位混合调制方法，以达到更高的信息传输速率。) 2.2.3 信道的极限容量数字通信的优点：虽然信号在信道上传输时会不可避免地产生失真，但在接收端只要我们从失真的波形中能够识别出原来的信号，那么这种失真对通信质量就没有影响。 码元传输的速率越高，或信号传输的距离越远，或噪声干扰越大，或传输媒体质量越差，在接收端的波形失真就越严重。 概念上，限制码元在信道上的传输速率的因素有两个： 信道能够通过的频率范围 信号中的许多高频分量有时不能通过信道或者传输时受到衰减，那么波形前沿和后沿则变得不那么陡峭，每个码元所占时间界限也不是很明确，这种现象叫做码间串扰。 奈氏准则： 在任何信道中，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决(识别)成为不可能。 信噪比 信噪比即为信号的平均功率和噪声的平均功率只比，常记为S/N，单位为分贝(dB)。 信噪比(dB)=10log_{10}(S/N) (dB) 香农公式：信道的极限信息传输速率C是 C=Wlog_2(1+S/N)(bit/s) 其中，W为信道的带宽(单位:Hz)，S为信道内所传信号的平均功率，N为信道内不得高斯噪声功率。 香农公式表明：信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。 香农公式意义：只要信息传输速率低于信道的极限信息传输速率，就一定存在某种办法来实现无差错的传输。 提高信息传输速率的方法：通过编码的方法让每一个码元携带更多比特的信息量。 2.3 物理层下面的传输媒体传输媒体(又称传输介质或传输媒介)，是数据传输系统中在发送器和接收器之间的物理通路。可分为两大类：导引型传输媒体和非导引型传输媒体(“引导型”(guided)，也可译为”导向传输媒体”)。导引型中，电磁波沿着固体媒体传播，非导引型中，电磁波传输常称为无线传输。 2.3.1 导引型传输媒体双绞线又称双扭线，由两个互相绝缘的铜导线并排放在一起，然后用规则的方法绞合(twist)起来构成。几乎所有的电话都用双绞线连接到电话交换机，这段线称为用户线或用户环路。常将一定数量的双绞线捆成电缆外包护套使用。 双绞线外面加一层用金属丝编织成的屏蔽层，便成了屏蔽双绞线，简称STP(Shielded Twisted Pair)，可提高双绞线抗电磁干扰能力。无屏蔽双绞线简称UTP(Unshielded Twisted Pair)。 对传送数据来说，现在最常用的UTP是5类线(Category 5 或 CAT5)。5类线的绞合长度是0.6~0.85cm。 衰减随频率的升高而增大。 导线粗可以降低衰减，但是重量和价格会增加。 双绞线的最高速率还和数字信号的编码方法有很大关系。 同轴电缆同轴电缆由内导体铜制芯线(单股实心线或多股绞合线)、绝缘层、网状编织的外导体屏蔽层(也可单股)以及保护塑料外层所组成。具有很好的抗干扰特性，被广泛用于传输速率较高的数据。 同轴电缆的带宽取决于电缆的质量。 光缆光纤是光纤通信的传输媒体。在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲的作用下能产生光脉冲。在接收端利用光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。 光纤通常由非常透明的石英玻璃拉成细丝，主要由纤芯和包层构成双层通信圆柱体。包层较纤芯有较低的折射率，可以折射光线，从而传输光。 多模光纤单模光纤多模光纤：同时存在多条不同角度入射的光线在一条光纤中传输。 因为光脉冲在多模光纤中国传输时会逐渐展宽，造成失真， 所以只适合于近距离传输。 单模光纤：光纤的直径减小到只有一个光的波长，则可使光纤一直向前传播，而不会产生多次反射。 纤芯细，制造成本高，光源要使用昂贵的半导体激光器。 但衰耗较小。 光纤极细，因此常做成光缆进行工程使用。下图为四芯光缆剖面示意图。 光纤特点： 通信容量非常大。 传输损耗小，中继距离长，对远距离传输特别经济。 抗雷电和电磁干扰性能好。在有大电流脉冲干扰的环境下尤为重要。 无串音干扰，保密性好，也不易被窃听或截取数据。 体积小，重量轻。在现有电缆管道已拥堵不堪的情况下特别有利。 架空明线指在电线杆上架设的相互绝缘的明线。通信质量差，受气候环境等影响较大，许多国家已停止铺设架空明线，目前我国一些农村和边远地区的通信仍使用架空明线。 2.3.2 非引导型传输媒体利用无线信道进行信息传输是在运动中通信的唯一手段。 短波通信即高频通信主要是靠电离层的反射。但电离层的不稳定所产生的衰落现象和电离层反射产生的多径效应，使得短波信道的通信质量较差。因此短波通信一般都是低速传输。 无线电微波通信传统上有两种方式，即地面微波接力通信和卫星通信。 微波在空间主要是直线传播。而地球表面是曲面，因此传播距离一般只有50km左右。通过终端间建立多个中继站(将送来的信号经放大后发送给下一站，称为”接力”)可以实现远距离传输。 微波接力通信主要特点： 微波频段频率很高，其频段范围也很宽，因此其通信信道的容量很大。 因为工业干扰和天电干扰的主要频谱成分比微波频率低得多，对微波通信的危害比对短波和米波(即甚高频)通信小得多，因而微波传输质量较高。 与相同容量和长度的电缆载波通信比较，微波接力通信建设投资少，见效快，易于跨越山区、江河。 微波接力通信存在缺点： 相邻站之间必须直视(常称为LOS(Line Of Sight))，不能有障碍物。有时一个天线发射出的信号也会分成几条略有差别的路径到达接收天线，因而造成失真。 微波的传输有时也会受到恶劣天气的影响。 与电缆通信系统比较，微波通信的隐蔽性和保密性较差。 对大量中继站的使用和维护要耗费较多的人力和物力。 卫星通信是将人造同步地球卫星作为中继器。 最大特点是通信距离远，且通信费用与通信距离无关。 卫星通信的频带很宽，通信容量很大，信号所受到的干扰也较小，通信比较稳定。 卫星通信有较大的传播时延。一般可取为270ms。地面微波接力通信链路的传播时延一般取为3.3μs/km。 低轨道卫星通信系统也可使用。 红外通信、激光通信也使用非引导型媒体。 2.4 信道复用技术频分复用、时分复用和统计时分复用]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构题集(C语言版)第一章]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E9%9B%86-C%E8%AF%AD%E8%A8%80%E7%89%88-%E7%AC%AC%E4%B8%80%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[基础知识题1.1① 简述下列术语：数据、数据元素、数据对象、数据结构、存储结构、数据类型和抽象数据类型。解答答案数据(data)是对客观事物的符号表示。在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。数据元素(data element)是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。数据对象(data object)是性质相同的数据元素的集合，是数据的一个子集。数据结构(data structure)是相互之间存在一种或多种特定关系的数据元素的集合。存储结构（物理结构）是数据结构在计算机中的表示（又称映像）。数据类型(data type)是一个值的集合和定义在这个值集上的一组操作的总称。抽象数据类型(Abstract Data Type)是指一个数学模型以及定义在该模型上的一组操作。 (选自康建伟博客, 地址: https://www.cnblogs.com/kangjianwei101/p/5221816.html) 1.2② 试描述数据结构和抽象数据类型的概念与程序设计语言中数据类型概念的区别。解答答案简单地说，数据结构定义了一组按某些关系结合在一起的数组元素。数据类型不仅定义了一组带结构的数据元素，而且还在其上定义了一组操作。 (选自康建伟博客, 地址: https://www.cnblogs.com/kangjianwei101/p/5221816.html) ◇1.3② 设有数据结构（D，R），其中：D={d1,d2,d3,d4}，R={r}，r={(d1,d2),(d2,d3),(d3,d4)}。试按图论中图的画法惯例画出其逻辑结构图。解答答案d1 -&gt; d2 -&gt; d3 -&gt; d4 (选自康建伟博客, 地址: https://www.cnblogs.com/kangjianwei101/p/5221816.html) ◇1.4② 试仿照三元组的抽象数据类型分别写出抽象数据类型复数和有理数的定义（有理数是其分子、分母均为自然数且分母不为零的分数）。解答答案123456789101112131415161718192021222324252627ADT Complex&#123; 数据对象：D = &#123;e1, e2| e1, e2∈R&#125; 数据关系：R1 = &#123;e1, e2&#125; 基本操作： InitComplex(&amp;C, v1, v2) 操作结果：构造复数C，元素e1，e2分别被赋以参数v1，v2的值。 DestroyComplex(&amp;C) 操作结果：复数C被销毁。 GetRealPart(C, &amp;e) 初始条件：复数C已存在。 操作结果：用e返回C的实部。 GetImaginaryPart(C, &amp;e) 初始条件：复数C已存在。 操作结果：用e返回C的虚部。 PutRealPart(&amp;C, e) 初始条件：复数C已存在。 操作结果：改变C的实部值为e。 PutImaginaryPart(&amp;C, e) 初始条件：复数C已存在。 操作结果：改变C的虚部值为e。 Add(C1, C2, &amp;C3) 初始条件：复数C1，C2已存在。 操作结果：将C1+C2的值赋给C3。 Subtract(C1, C2, &amp;C3) 初始条件：复数C1，C2已存在。 操作结果：将C1-C2的值赋给C3。&#125;ADT Complex 123456789101112131415ADT RationalNumber&#123; 数据对象：D = &#123;e1, e2|e1, e2 ∈ Q &amp;&amp; e2 != 0&#125; 数据关系：R1 = &#123;e1 / e2&#125; 基本操作： InitRationalNumber(&amp;R, v1, v2) 操作结果：构造有理数R，元素e1，e2分别被赋以参数v1，v2的值。 DestroyRationalNumber(&amp;R) 操作结果：有理数R被销毁。 Add(R1, R2, &amp;R3) 初始条件：有理数R1，R2已存在。 操作结果：将R1+R2的值赋给R3。 Subtract(R1, R2, &amp;R3) 初始条件：有理数R1，R2已存在。 操作结果：将R1-R2的值赋给R3。&#125;ADT RationalNumber12345678910111213141516171819202122232425262728293031复数定义：ADT Complex //复数定义 a±bi&#123; 数据对象：D = &#123;a, b | a,b为实数&#125; 数据关系：R = &#123;&lt;a, b&gt;&#125; 基本操作： InitComplex(&amp;C, re, im) 操作结果：构造一个复数C，其实部和虚部分别为re和im DestroyCmoplex(&amp;C) 操作结果：销毁复数C Get(C, k, &amp;e) 初始条件：复数C已存在 操作结果：用e返回复数C的第k元的值 Put(&amp;C, k, e) 初始条件：复数C已存在 操作结果：改变复数C的第k元的值为e IsAscending(C) 初始条件：复数C已存在 操作结果：如果复数C的两个元素按升序排列，则返回1，否则返回0 IsDescending(C) 初始条件：复数C已存在 操作结果：如果复数C的两个元素按降序排列，则返回1，否则返回0 Max(C, &amp;e) 初始条件：复数C已存在 操作结果：用e返回复数C的两个元素中值较大的一个 Min(C, &amp;e) 初始条件：复数C已存在 操作结果：用e返回复数C的两个元素中值较小的一个&#125;ADT Complex 12345678910111213141516171819202122232425262728293031有理数定义：ADT RationalNumber //有理数定义&#123; 数据对象：D=&#123;s, m | s,m为自然数，且m不为0&#125; 数据关系：R=&#123;&lt;s, m&gt;&#125; 基本操作： InitRationalNumber(&amp;R, s, m) 操作结果：构造一个有理数R，其分子和分母分别为s和m DestroyRationalNumber(&amp;R) 操作结果：销毁有理数R Get(R, k, &amp;e) 初始条件：有理数R已存在 操作结果：用e返回有理数R的第k元的值 Put(&amp;R, k, e) 初始条件：有理数R已存在 操作结果：改变有理数R的第k元的值为e IsAscending(R) 初始条件：有理数R已存在 操作结果：若有理数R的两个元素按升序排列，则返回1，否则返回0 IsDescending(R) 初始条件：有理数R已存在 操作结果：若有理数R的两个元素按降序排列，则返回1，否则返回0 Max(R, &amp;e) 初始条件：有理数R已存在 操作结果：用e返回有理数R的两个元素中值较大的一个 Min(R, &amp;e) 初始条件：有理数R已存在 操作结果：用e返回有理数R的两个元素中值较小的一个&#125;ADT RationalNumber 1.5② 试画出与下列程序段等价的框图。12345678//(1).product = 1; i = 1;while(i&lt;=n)&#123; product *= i; i++;&#125; 123456//(2).i=0;do&#123; i++;&#125;while((i!=n) &amp;&amp; (a[i]!=x)) 123456789101112//(3).switch&#123; case x&lt;y: z=y-x; break; case x==y: z=abs(x*y); break; default: z=(x-y)/abs(x)*abs(y);&#125; 解答答案(1)(2)(3)(1)(2)(3) ◇1.6③ 在程序设计中，常用下列三种不同的出错处理方式：（1）用exit语句终止执行并报告错误；（2）以函数的返回值区别正确返回或错误返回；（3）设置一个整型变量的函数参数以区别正确返回或某种错误返回。试讨论这三种方法各自的优缺点。解答答案（1）exit常用于严重错误处理，它可以强行中断程序的执行，返回操作系统。优点是可以在程序的任何地方关闭程序，缺点是隐藏了故障信息。（2）以函数的返回值判断正确与否常用于子程序的测试，便于实现程序的局部控制。（3）用整型变量进行错误处理的优点是可以给出错误类型，便于迅速定位错误。 (选自康建伟博客, 地址: https://www.cnblogs.com/kangjianwei101/p/5221816.html) ◇1.7③ 在程序设计中，可采用下列三种方法实现输出和输入：（1）通过scanf和printf语句；（2）通过函数的参数显式传递；（3）通过全局变量隐式传递。试讨论这三种方法的优缺点。解答答案（1）用scanf和printf直接进行输入输出的好处是形象、直观，但缺点是需要对其进行格式控制，较为烦琐，如果出现错误，则会引起整个系统的崩溃。（2）通过函数的参数传递进行输入输出，便于实现信息的隐蔽，减少出错的可能。（3）通过全局变量的隐式传递进行输入输出最为方便，只需修改变量的值即可，但过多的全局变量使程序的维护较为困难。 (选自康建伟博客, 地址: https://www.cnblogs.com/kangjianwei101/p/5221816.html) 1.8④ 设n为正整数。试确定下列各程序段中前置以记号@的语句的频度：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//(1)i = 1; k = 0;while(i &lt;= n-1)&#123;@ k += 10 * i; i++;&#125;// (2)i = 1; k = 0;do&#123;@ k += 10 * i; i++;&#125;while(i &lt;= n-1);// (3)i = 1; k = 0;while(i &lt;= n-1)&#123; i++;@ k += 10 * i;&#125;// (4)k = 0;for(i=1; i&lt;=n; i++)&#123; for(j=i; j&lt;=n; j++)@ k++;&#125;// ◇(5)for(i=1; i&lt;=n; i++) for(j=1; j&lt;=i; j++) for(k=1; k&lt;=j; k++)@ x += delta;// (6)i = 1; j = 0;while(i+j &lt;= n)&#123;@ if(i&gt;j) j++; else i++;&#125;// ◇(7)x = n; y = 0; //n是不小于1的常数while(x &gt;= (y+1)*(y+1))@ y++;// ◇(8)x = 91; y = 100;while(y&gt;0)&#123;@ if(x&gt;100) &#123; x -= 10; y--; &#125; else x++ ;&#125; 解答答案(1) n-1 (2) n-1 (3) n-1 (4) n(n+1)/2 (5) ∑(n(n+1)/2) (6) ceil(n/2) (7) floor(sqrt(n)) (8) 100 (ceil()向上取整，floor()向下取整)(1) n-1 (2) n-1 (3) n-1 (4) n(n+1)/2 (5) ∑(n(n+1)/2)=n(n+1)(2n+3)/12 (6) n (7) floor(sqrt(n)) (8) 1100 (ceil()向上取整，floor()向下取整) 1.9③ 假设n为2的乘幂，并且n&gt;2,试求下列算法的时间复杂度及变量count的值（以n的函数形式表示）。1234567891011int Time (int n)&#123; count = 0; x = 2; while(x&lt;n/2) &#123; x *= 2; count++; &#125; return (count)&#125;//Time 解答答案O(log2(n/4)) count = log2n/4O(log2n) count = log2n-2 1.10② 按增长率由小至大的顺序排列下列各函数：2100，(3/2)n，(2/3)n，(4/3)n，nn，n3/2，n2/3，√n，n！，n，log2n，n/log2n，log22n，log2(log2n)，nlog2n，nlog2n解答答案2100 &lt; log2(log2n) &lt; log2n &lt; log22n &lt; n/log2n &lt; √n &lt; n2/3 &lt; n &lt; nlog2n &lt; n3/2 &lt; (2/3)n &lt; (4/3)n &lt; (3/2)n &lt; nlog2n &lt; n! &lt; nn (2/3)n &lt; 2100 &lt; log2(log2n) &lt; log2n &lt; log22n &lt; √n &lt; n2/3 &lt; n/log2n &lt; n &lt; nlog2n &lt; n3/2 &lt; (4/3)n &lt; (3/2)n &lt; nlog2n &lt; n! &lt; nn 1.11③ 已知有实现同一功能的两个算法，其时间复杂度分别为O(2n)和O(n10)，假设现实计算机可连续运算的时间为107秒（100多天），又每秒可执行基本操作（根据这些操作来估算算法时间复杂度）105次。试问在此条件下，这两个算法可解问题的规模（即n值的范围）各为多少？哪个算法更适宜？请说明理由。解答答案107 105 = 1012(次)对于O(2n): 令2n &lt;= 1012,得： n &lt;= log21012 = 12log210 ≈ 12 3.3219 = 39.8628 对于O(n10): ​ 令n10 &lt;= 1012,得： ​ n &lt;= 101.2 ≈ 15.8489 第一种更好， 在相同的时间内客运行次数更多，即效率更高。2n=1012，求得n=40n10=1012，求得n=16故第一种算法较适宜。因为在同样的算力下，第一种算法可解的n值较大。由此可见，虽然一般情况下多项式阶的算法优于指数阶的算法，但高次多项式的算法在n的很大范围内不如某些指数阶的算法。 1.12③ 设有以下三个函数：f(n)=21n4+n2+1000，g(n)=15n4+500n2，h(n)=5000n3.5+nlogn请判断以下断言正确与否：（1）f(n)是O(g(n))（2）h(n)是O(f(n))（3）g(n)是O(h(n))（4）h(n)是O(n3.5)（5）h(n)是O(nlogn)解答答案√ × × √ ×(1) 对 (2) 错 (3) 错 (4) 对 (5) 错 1.13③ 试设定若干n值，比较两函数n2和50nlog2n的增长趋势，并确定n在什么范围内时n2的值大于50nlog2n。解答答案n = 1 时，左边 = 1 &gt; 0 = 右边 n = 2时，左边 = 4 &lt; 100 = 右边 令n2 = 50nlog2n，得： n = 50log2n if n = 210 = 1024,则: 左边 = 1024 &gt; 500 = 右边 if n = 29 = 512,则: 左边 = 512 &gt; 450 = 右边 if n = 28 = 256,则: 左边 = 256 &lt; 400 = 右边 if n = 400&gt; 28,则: log2400 &gt; 8 ,所以左边 &lt; 右边 if n = 450 则: 右边 = 50*log2450 = 440.6891 &lt; 左边 if n = 430 则: 右边 = 50*log2430 = 437.4096 &gt; 左边 if n = 440 则: 右边 = 50*log2440 = 439.0680 &lt; 左边 ∴ 430 &lt; n &lt; 440大约在n&gt;450时 ，函数n2的值才大于函数50nlog2n的值。 1.14③ 判断下列各对函数f(n)和g(n)，当n→∞时，哪个函数增长更快？(1) f(n) = 102 + ln(n! + 10n3&lt;/sup&gt;) g(n) = 2n4 + n + 7(2) f(n) = (ln(n!) + 5)2 g(n) = 13n2.5(3) f(n) = n2.1 + √(n4 + 1) g(n) = (ln(n!))2 + n(4) f(n) = 2(n3)&lt;/sup&gt; + (2n)2 g(n) = nn2&lt;/sup&gt; + n5解答答案(1) f(n) (2) f(n) (3) g(n) (4) g(n)(1) g(n) (2) g(n) (3) f(n) (4) f(n) 1.15③ 试用数学归纳法证明： (1) \sum^n_{i=1}{i^2} = \frac{n(n+1)(2n+1)}6 (n≥0) (2)\sum^n_{i=0}x^i = \frac{x^{n+1}-1}{x-1}(x≠1,n≥0) (3)\sum^n_{i = 1}2^{i-1} = 2^n-1(n≥1) (4)\sum^n_{i = 1}(2i-1) = n^2(n≥1)解答答案(1)(2)(3)(4)当n = 0时，左边 = 0， 右边= 0，等式成立， 当n &gt;0时， 假设等式成立，令n = k (k&gt;0)，则有： \sum^k_{i=1}{i^2} = \frac{k(k+1)(2k+1)}6 (k>0)那么，当n = k+1时， \sum^{k+1}_{i=1}{i^2} = \frac{k(k+1)(2k+1)}6+(k+1)^2=\frac{k(k+1)(2k+1)+2(k+1)(3k+3)}6 =\frac{(k+1)(2k^2+7k+6)}6=\frac{(k+1)(k+2)(2(k+1)+1)}6那就是说，n=k+1时，等式仍成立，∴k&gt;0时等式成立。 又∵k=0时，等式成立，∴k≥0时等式成立，得证。n = 0时，左边 = 1， 右边= 1，等式成立， 当n &gt;0时， 假设等式成立，令n = k (k&gt;0)，则有： \sum^k_{i=0}x^i = \frac{x^{k+1}-1}{x-1}(x≠1,k>0)那么，当n = k+1时， \sum^{k+1}_{i=0}x^i = \frac{x^{k+1}-1}{x-1}+x^{k+1}=\frac{x^{k+1}-1}{x-1}+\frac{x^{k+2}-x^{k+1}}{x-1}=\frac{x^{k+2}-1}{x-1}那就是说，n=k+1时，等式仍成立，∴k&gt;0时等式成立。 又∵k=0时，等式成立，∴k≥0时等式成立，得证。n = 1时，左边 = 1， 右边= 1，等式成立， 当n &gt;1时， 假设等式成立，令n = k (k&gt;1)，则有： \sum^k_{i = 1}2^{i-1} = 2^k-1(n>1)那么，当n = k+1时， \sum^{k+1}_{i = 1}2^{i-1} = 2^k-1+2^k=2^{k+1}-1那就是说，n=k+1时，等式仍成立，∴k&gt;1时等式成立。 又∵k=1时，等式成立，∴k≥1时等式成立，得证。n = 1时，左边 = 1， 右边= 1，等式成立， 当n &gt;1时， 假设等式成立，令n = k (k&gt;1)，则有： \sum^k_{i = 1}(2i-1) = k^2(n>1)那么，当n = k+1时， \sum^{k+1}_{i = 1}(2i-1) = k^2+2(k+1)-1=k^2+2k+1=(k+1)^2那就是说，n=k+1时，等式仍成立，∴k&gt;1时等式成立。 又∵k=1时，等式成立，∴k≥1时等式成立，得证。略 算法设计题◇1.16② 试写一算法，自大到小依次输出顺序读入的三个整数X，Y和Z的值。解答答案1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;void BigToSmallSort(int &amp;a, int &amp;b);int main(int argc, char const *argv[])&#123; int X, Y, Z;​ printf("请输入三个整数：");​ scanf("%d %d %d", &amp;X, &amp;Y, &amp;Z);​ BigToSmallSort(X, Y);​ BigToSmallSort(X, Z);​ BigToSmallSort(Y, Z);​ printf("自大到小依次输出顺序：%d %d %d \n", X, Y, Z);​ return 0;&#125;void BigToSmallSort(int &amp;a, int &amp;b)&#123; // 将a和b按a &gt; b排列 if (a &lt; b) &#123; a += b; b = a - b; a -= b; &#125;&#125;// BigToSmallSort1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;/* 函数原型 */void Algo_1_16(int i, int j, int k);int main(int argc, char *argv[])&#123; int i, j, k;​ i = 3;​ j = 7;​ k = 1;​ printf("作为示范，设定依次读入的三个整数为：%d %d %d...\n", i, j, k);​ printf("这三个数从大到小的顺序为：");​ Algo_1_16(i, j, k);​ printf("\n");​ return 0;&#125;/*━━━━━━━━━━━━━━━━━━┓┃题1.16：将3个整数按从大到小顺序输出 ┃┗━━━━━━━━━━━━━━━━━━*/void Algo_1_16(int i, int j, int k)&#123; int tmp;​ if(i&lt;j)​ &#123;​ tmp = i;​ i = j;​ j = tmp;​ &#125;​ if(j&lt;k)​ &#123;​ tmp = j;​ j = k;​ k = tmp; ​ &#125;​ if(i&lt;j)​ &#123;​ tmp = i;​ i = j;​ j = tmp;​ &#125; ​ printf("%d %d %d\n", i, j, k);&#125; 1.17③ 已知k阶斐波那契序列的定义为f0=0, f1=0, …, fk-2=0, fk-1=1;fn=fn-1+fn-2+…+fn-k, n=k,k+1,…试编写求k阶斐波那契序列的第m项值的函数算法，k和m均以值调用的形式在函数参数表中出现。解答答案1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;int KFibonacci(int k, int m); // 求k阶斐波那契序列的第m项值int main(int argc, char const *argv[])&#123; int k, m;​ printf("本程序求k阶斐波那契序列的第m项值，请输入需求值的k和m(k和m均为正整数)：");​ scanf("%d %d", &amp;k, &amp;m);​ while (k &lt;= 0 || m &lt;= 0)​ &#123;​ printf("k,m值错误，请重新输入(k和m均为正整数)：");​ scanf("%d %d", &amp;k, &amp;m);​ &#125;​ printf("所求函数值为：%d\n", KFibonacci(k, m));​ return 0;&#125;int KFibonacci(int k, int m)&#123;// 求k阶斐波那契序列的第m项值​ if (m &lt; k)​ return 0;​ else if ((m - k) &lt;= 1)​ return 1;​ else​ return (KFibonacci(k, m-1) + KFibonacci(k, m-2));&#125;// KFibonacci()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; //提供malloc、realloc、free、exit原型#include "../../../▲课本算法实现/▲01 绪论/Status.h" //**▲01 绪论**///* 函数原型 */int Algo_1_17_1(int k, int m);int Algo_1_17_2(int k, int m);int main(int argc, char *argv[])&#123; int k, m;​ k = 3;​ m = 10;​ printf("作为示范，求得 %d 阶斐波那契数列第 %d 项的值为：%d \n", k, m, Algo_1_17_1(k, m));​ printf("作为示范，求得 %d 阶斐波那契数列第 %u 项的值为：%d \n", k, 2*m, Algo_1_17_2(k, 2*m));​ printf("\n");​ return 0;&#125;/*━━━━━━━━━━━━━━━━━━┓┃题1.17：计算k阶斐波那契数列第m项的值┃┗━━━━━━━━━━━━━━━━━━*//* 方法1：递归算法 */int Algo_1_17_1(int k, int m) //当m变大时，计算速度会递减 &#123; int i, value;​ if(k&lt;2 || m&lt;0)​ exit(OVERFLOW);​ if(m&lt;k-1)​ return 0;​ else if(m==k-1)​ return 1;​ else​ &#123;​ for(i=1,value=0; i&lt;=k; i++)​ value += Algo_1_17_1(k, m-i);​ return value;​ &#125;&#125;/*━━━━━━━━━━━━━━━━━━┓┃题1.17：计算k阶斐波那契数列第m项的值┃┗━━━━━━━━━━━━━━━━━━*//* 方法2：递推（迭代）算法 */int Algo_1_17_2(int k, int m)&#123; int i, j; int fib[m+1];​ if(k&lt;1 || m&lt;0)​ exit(OVERFLOW);​ i = 0;​ while(i&lt;k-1)​ &#123;​ fib[i] = 0;​ i++; ​ &#125;​ fib[i] = 1; //i = k-1​ i++;​ while(i&lt;=m) //i = k​ &#123; ​ for(j=i-1,fib[i]=0; j&gt;=i-k; j--)​ fib[i] += fib[j];​ i++;​ &#125;​ return fib[m]; &#125; 1.18③ 假设有A、B、C、D、E五个高等院校进行田径对抗赛，各院校的单项成绩均已存入计算机，并构成一张表，表中每一行的形式为： 项目名称 性别 校名 成绩 得分 编写算法，处理上述表格，以统计各院校的男、女总分和团体总分，并输出。解答答案112345678910111213141516171819202122232425262728293031typedef enum &#123;A, B, C, D, E&#125; SchoolName;typedef enum &#123;FEMALE, MALE&#125; SexType;typedef enum &#123;X, Y, Z&#125; Event; typedef struct&#123; Event e; //项目名称 SexType sex; //性别 SchoolName school; //校名 int score; //得分 &#125;Component;typedef struct&#123; int malesum; //男团总分 int femalesum; //女团总分 int totalsum; //团体总分&#125;Sum;Component report[n]; //n条记录 Sum result[5];//算法过程体中主要结构 for(i=0; i&lt;n; i++)&#123; //对result[report[i].school]进行处理 &#125;for(s=A; s&lt;=E; s++)&#123; //printf(...);&#125; ◇1.19④ 试编写算法，计算i! 2i(i = 0,1,…,n-1) 的值并存入数组a[arrsize]的各个分量中。假设计算机中允许的整数最大值为MAXINT，则当n&gt;arrsize或对某个k(0≤k≤n-1)使k! 2k&gt;MAXINT时，应按出错处理。注意选择你认为较好的出错处理方法。解答答案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; // 提供exit()#include &lt;limits.h&gt; //提供宏INT_MAX #define MAXINT INT_MAXvoid Calculate(int a[], const int i);int main(int argc, char const *argv[])&#123; int arrsize = 1; int a[arrsize]; int n;​ printf("请输入arrsize值和n值(arrsize ≥ 1, 0 ≤ n ≤arrsize)：");​ scanf("%d %d", &amp;arrsize, &amp;n);​ if (arrsize &lt; 1 || n &gt; arrsize)​ &#123;​ printf("输入错误，请重新输入arrsize值和n值(arrsize ≥ 1, 0 ≤ n ≤arrsize)：");​ scanf("%d %d", &amp;arrsize, &amp;n);​ &#125;​ Calculate(a, n);​ for (int j = 0; j &lt; n; j++)​ printf("%d ",a[j]);​ printf("\n");; ​ return 0;&#125;void Calculate(int a[], const int i)&#123;// 计算值​ int product1 = 1;​ int product2 = 1;​ a[0] = 1;​ for (int j = 1; j &lt;= i; j++)​ &#123;​ product1 *= j;​ product2 *= 2;​ if (MAXINT / product1 &lt; product2)​ &#123;​ printf("最大值溢出，请选择合适的i值。\n");​ exit(1);​ &#125;​ a[j] = product1 * product2;​ &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;limits.h&gt; //提供宏INT_MAX #include "../../../▲课本算法实现/▲01 绪论/Status.h" //**▲01 绪论**///* 宏定义 */#define arrsize 20 //数组长度 #define maxint INT_MAX //最大的整数 /* 函数原型 */Status Algo_1_19(int i, int a[]);int main(int argc, char *argv[])&#123; int i, a[arrsize]; ​ i = 5;​ printf("计算i!*2^i...\n");​ if(Algo_1_19(i, a)==OK)​ printf("作为示例，计算当i = %d 时，a[i-1] = %d\n", i, a[i-1]);​ printf("\n");​ return 0;&#125;/*━━━━━━━━━━━━━━━━━━━┓┃题1.19：计算i!*2^i存入a[i-1]，i起点为1┃┗━━━━━━━━━━━━━━━━━━━*/Status Algo_1_19(int i, int a[])&#123; int j; ​ if(i&lt;1 || i&gt;arrsize)​ return ERROR;​ for(j=1; j&lt;=i; j++)​ &#123;​ if(j==1)​ a[j-1] = 2;​ else​ &#123;​ if(maxint/(2*j)&lt;a[j-2])​ return OVERFLOW;​ a[j-1] = 2 * j * a[j-2]; ​ &#125; ​ &#125;​ return OK;&#125; ◇1.20④ 试编写算法求一元多项式：$P_n(x) = \sum^n_{i=0}a_ix^i$的值Pn(x0)，并确定算法中每一语句的执行次数和整个算法的时间复杂度。注意选择你认为较好的输入和输出方法。本题的输入为ai(i=0,1,…,n)，x0和n，输出为Pn(x0)。解答答案改123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;math.h&gt;int Calculate(const int ai, const int x0, const int i);int main(int argc, char const *argv[])&#123; int ai, x0, n; printf("请输入ai(i=0,1,…,n) x0 n："); scanf("%d %d %d", &amp;ai, &amp;x0, &amp;n);​ while (n &lt;= 0)​ &#123;​ printf("n值输入错误，请重新输入n：");​ scanf("%d", &amp;n);​ &#125;​ printf("P%d(%d) = %d\n", n, x0, Calculate(ai, x0, n));​ return 0;&#125;int Calculate(const int ai, const int x0, const int i)&#123;// 计算值,公式化简得Pn(x0)=ai*x0*(1-x0^i)/(1-x0)​ return ai * x0 * (1 - pow(x0, i)) / (1 - x0);&#125;123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;math.h&gt; //提供pow原型 /* 函数原型 */int Algo_1_20(int a[], int x, int n);int main(int argc, char *argv[])&#123; int a[5] = &#123;-2, 3, 6,-8, 7&#125;; int n = 5; int Xo = 3; ​ printf("作为示范，设定项数n = 5，变量Xo = 3，计算Pn(Xo)...\n");​ printf("P%d(%d) = %d\n", n, Xo, Algo_1_20(a, Xo, n));​ printf("\n");​ return 0;&#125;/*━━━━━━━━━━━━━━┓┃题1.20：计算多项式Pn(Xo)的值┃┗━━━━━━━━━━━━━━*/int Algo_1_20(int a[], int x, int n)&#123; int i; int tmp; ​ for(i=1,tmp=0; i&lt;=n; i++)​ tmp += a[i-1]*pow(x, i-1);return tmp;&#125;输入ai(i=0,1,…,n)是个数组而不是单个数值 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;math.h&gt;int Calculate(const int ai[], const int x0, const int i);int main(int argc, char const *argv[])&#123; int x0, n, i; printf("请输入x0 n："); scanf("%d %d", &amp;x0, &amp;n);​ while (n &lt;= 0)​ &#123;​ printf("n值输入错误，请重新输入n：");​ scanf("%d", &amp;n);​ &#125;​ int ai[n] = &#123; 0 &#125;;​ printf("请依次输入ai(n个数值)：");​ for (i = 0; i &lt; n; i++)​ scanf("%d", &amp;ai[i]);​ printf("P%d(%d) = %d\n", n, x0, Calculate(ai, x0, n));return 0;&#125;int Calculate(const int ai[], const int x0, const int i)&#123;// 计算值 int j, sum = 0;​ for (j = 0; j &lt; i; j++)​ sum += ai[j] * pow(x0, j);return sum;&#125;st=>start: (1)开始 e=>end: 结束 op1=>operation: porduct=1 i=1 cond=>condition: i ≤ n ? op2=>operation: product *= i op3=>operation: i++ st->op1 op1->cond cond(yes)->op2 op2->op3 op3->cond cond(no)->e{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);st=>start: (2)开始 e=>end: 结束 op1=>operation: i = 0 op2=>operation: i++ cond=>condition: (i != n) && (a[i] != x) st->op1 op1->op2 op2->cond cond(no)->op2 cond(yes)->e{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-1-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-1", options);st=>start: (3)开始 e=>end: 结束 cond1=>condition: x < y ? cond2=>condition: x == y ? op1=>operation: z = y - x op2=>operation: z = abs(x * y) op3=>operation: z = (x - y) / abs(x) * abs(y) st->cond1 cond1(yes)->op1 op1->e cond1(no)->cond2 cond2(yes)->op2 op2->e cond2(no)->op3 op3->e{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-2-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-2", options);st=>start: (1)开始 e=>end: 结束 put=>inputoutput: 输入n op1=>operation: porduct=1 i=1 cond=>condition: i ≤ n ? op2=>operation: product *= i op3=>operation: i++ st->put put->op1 op1->cond cond(yes)->op2 op2->op3 op3->cond cond(no)->e{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-3-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-3-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-3", options);st=>start: (2)开始 e=>end: 结束 put=>inputoutput: 输入n,x op1=>operation: i = 0 op2=>operation: i++ cond=>condition: (i != n) && (a[i] != x) st->put put->op1 op1->op2 op2->cond cond(yes)->op2 cond(no)->e{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-4-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-4-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-4", options);st=>start: (3)开始 e=>end: 结束 put=>inputoutput: 输入x,y cond1=>condition: x < y ? cond2=>condition: x == y ? op1=>operation: z = y - x op2=>operation: z = abs(x * y) op3=>operation: z = (x - y) / abs(x) * abs(y) st->put put->cond1 cond1(yes)->op1 op1->e cond1(no)->cond2 cond2(yes)->op2 op2->e cond2(no)->op3 op3->e{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-5-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-5-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-5", options);]]></content>
      <categories>
        <category>习题</category>
      </categories>
      <tags>
        <tag>习题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络(第7版)谢希仁-第一章绪论]]></title>
    <url>%2F2019%2F07%2F27%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC7%E7%89%88-%E8%B0%A2%E5%B8%8C%E4%BB%81-%E7%AC%AC%E4%B8%80%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[本课程重要概念：计算机网络的体系结构。 本章重要内容： 互联网边缘部分和核心部分的作用，其中包含分组交换的概念。 计算机网络的性能指标。 计算机网络分层次的体系结构，包含协议和服务的概念。 计算机网络在信息时代中的作用 互联网两个重要基本特点：连通性和共享。 互联网概述网络的网络 计算机网络(简称网络)由若干结点(node)和连接这些节点的链路(link)组成。网络之间通过路由器互连起来，构成一个覆盖范围更大的计算机网络，成为互连网(“网络的网络”)。 网络把许多计算机连接在一起，互连网把许多网络通过路由器连接在一起。与网络相连的计算机常称为主机。 互联网基础结构发展的三个阶段 一阶段是从单个网络ARPANET向互连网发展的过程。 1983年TCP/IP协议成为ARPANET上的标准协议，使得所有使用TCP/IP协议的计算机都能利用互连网相互通信，因而将1983年作为互联网的诞生时间。所以互联网Internet前身为美国的ARPANET。 二阶段特点是建成了三级结构的互联网。 三级计算机网络分为主干网、地区网和校园网(企业网)。 三阶段特点是逐渐形成多层次ISP结构的互联网。 互联网服务提供商(Internet Service Provider)。 互联网交换点IXP(Internet eXchange Point)：主要作用是允许两个网络直接相连并交换分组，而不再需要通过第三个网络来转发分组。由此可以更快地转发分组，更加有效地利用网络资源。 互联网的标准化工作 互联网的组成互联网可分为两部分： ​ -边缘部分。由所有连接在互联网上的主机组成，用户直接使用。 ​ -核心部分。由大量网络和路由器组成，为边缘部分提供服务。 互联网的边缘部分端系统(边缘部分主机又称)之间的通信方式分为两大类：客户-服务器方式(C/S 方式)和对等方式(P2P 方式)。 客户-服务器方式对等方式 (client/server) ​ 客户(client)是服务请求方，服务器(server)是服务提供方。 客户程序： ​ 1.被用户调用后运行，在通信时主动向远地服务器发起通信。须知道服务器程序地址。 ​ 2.不需要特殊的硬件和很复杂的操作系统。 服务器程序： ​ 1.是一种专门用来提供某种服务的程序，可同时处理多个客户请求。 ​ 2.不需知道客户程序地址。 ​ 3.一般有强大的硬件和高级的操作系统支持。(peer-to-peer) 双方进行平等的、对等连接通信。 本质上看仍然是使用C/S方式，只是主机既是客户又同时是服务器。 互联网的核心部分在核心部分起特殊作用的是路由器，它是实现分组交换的关键构件，任务是转发收到的分组。 分组交换采用存储转发技术。将数据分段为多个更小的等长数据段，在数据段前面添加首部，构成分组，又称”包”，首部又称”包头”。 分组交换的优点： ​ 1.高效。在分组传输的过程中动态分配传输带宽，对通信链路逐段占用 ​ 2.灵活。为每个分组独立地选择最合适的转发路由 ​ 3.迅速。以分组作为传送单位，可以先不建立连接就能发送分组 ​ 4.可靠。分布式多路由的分组交换网 分组交换的问题：时延与开销。 电路交换适合于数据量很大的实时性传输。 计算机网络在我国的发展中国1994年4月20日用一条64kbit/s专线正式连入互联网。 事件： ​ 1996年张朝阳创立爱特信公司，推出”搜狐” ​ 1997年丁磊创立网易公司 ​ 1998年王志东创立新浪网站 ​ 1998年马化腾+张志东创立腾讯公司 ​ 1999年马云创立阿里巴巴网站 ​ 2000年李彦宏+徐勇创建百度网站 计算机网络的类别计算机网络的定义目前较好的定义：计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的。 几种不同类别的计算机网络 计算机网络的性能计算机网络的性能指标速率网络技术中的速率指的是数据的传送速率，也成为数据率(data rate)或比特率(bit rate)。单位是 bit/s(或 b/s ,有时也写为 bps，即 bit per second)。 k = 103 = 千；M = 106 = 兆； G = 109 = 吉；T = 1012 = 太；P = 1015 = 拍；… 网络的速率指额定速率或标称速率。 带宽一条通信链路的”带宽”越宽，其所能传输的”最高数据率”越高。 意义1意义2本来是指某个信号具有的频带宽度。这种意义下的带宽的单位是赫(或千赫、兆赫、吉赫等)。 表示某信道允许通过的信号频带范围就成为该信道的带宽(或通频带)。在计算机网络中，带宽用来表示网络中某通道传送数据的能力，因此网络带宽表示在单位时间内网络中某信道所能通过的”最高数据率”。该意义下带宽单位是 bit/s。 吞吐量单位时间内通过某个网络(或信道、接口)的实际的数据量。 受网络带宽或网络额定速率限制。 时延数据从网络(或链路)的一端传送到另一端所需的时间。有时也称为延迟或迟延。 时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延 一条通信链路的”带宽”越宽，其所能传输的”最高数据率”越高。 发送时延传播时延处理时延排队时延主机或路由器发送数据帧所需要的时间。又称传输时延。 发送时延 = \frac{数据帧长度(bit)}{发送速率(bit/s)}电磁波在信道中传播一定距离需要花费的时间。 传播时延 = \frac{信道长度(m)}{电磁波在信道上的传播速率(m/s)}1000km唱的光纤线路产生的传播时延大约为5ms。主机或路由器在收到分组时要花费一定时间进行处理从而产生的时延。分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发。由此产生的时延。 时延带宽积 时延带宽积 = 传播时延 * 带宽链路的时延带宽积又称为以比特为单位的链路长度。 往返时间RTT 发送时间 = \frac{数据长度}{发送速率} 有效数据率 = \frac{数据长度}{发送时间 + RTT}往返时间还包括中间结点处理时延、排队时延、转发数据的发送时延。 利用率信道利用率网络利用率信道利用率指出某信道有百分之几的时间是被利用的(有数据通过)。 信道利用率并非越高越好：当某信道的利用率增大时，其引起的时延也迅速增加。网络利用率是全网络的信道利用率的加权平均值。 网络当前时延 = \frac{网络空闲时的时延}{1 - 网络的利用率} 计算机网络的非性能特征费用 质量 标准化 可靠性 可扩展性和可升级性 易于管理和维护 计算机网络体系结构 计算机网络体系结构的形成拓展，根据韩立刚老师计算机网络课程补充知识OSI参考模型分7层 (程序开发人员考虑问题↓) 应用层。能够产生网络流量和用户交互的应用程序。 表示层。数据的加密，压缩，编码等。 会话层。服务和客户端建立的会话。 (网络工程师↓) 传输层。可靠传输(建立会话)，不可靠传输(不建立会话)，流量控制。 网络层。选择最佳路径，IP地址编址。 数据链路层。数据如何封装，添加物理层地址(MAC地址)。 (标准化设备↓) 物理层。电压，接口标准。 网络排错：低层往高层逐一排查。 网络安全和OSI参考模型： ​ 物理层安全。 ​ 数据链路层安全。 ​ 网络层安全。 ​ 应用层安全。 协议与划分层次为进行网络中的数据交换而建立的规则、标准或约定成为网络协议，简称协议。 网络协议由三个要素组成：语法；语义；同步。 分层结构好处： 各层之间是独立的。 灵活性好。 结构上可分隔开。 易于实现和维护。 能促进标准化工作。 各层要完成的功能： 差错控制 流量控制 分段和重装 复用和分用 连接建立和释放 计算机网络的体系结构就是这个计算机网络及其构件所应完成的功能的精确定义。 具有五层协议的体系结构(五层协议的体系结构只是为介绍网络原理而设计，实际应用TCP/IP是四层体系结构) 应用层运输层网络层数据链路层物理层(application layer) 任务是通过应用进程间的交互来完成特定的网络应用。 应用层协议定义的是应用进程间通信和交互的规则。 应用层交互的数据单元成为报文(message)。(transport layer) 任务是负责向两台主机中进程之间的通信提供通用的数据传输服务。 运输层主要用两种协议：传输控制协议TCP与用户数据报协议UDP。 传输控制协议用户数据报协议(Transmission Control Protocol) 提供面向连接的、可靠的数据传输服务，数据传输单位是报文段。(User Datagram Protocol) 提供无连接的、尽最大努力的数据传输服务(不保证可靠性)，数据传输单位是用户数据报。(network layer) 任务是为分组交换网上的不同主机提供通信服务。 分组也被称为IP数据报，或简称数据报。 网络层又称网际层或IP层。(data link layer) 常简称为链路层。 在两个相邻结点间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，再在链路上传送帧。物理层上所传数据的单位是比特。 考虑多大电压代表”1”或”0”， 还要确定连接电缆的插头有多少根引脚以及引脚的连接方式。 实体、协议、服务和服务访问点实体表示任何可发送或接收信息的硬件或软件进程。 协议是控制两个对等实体(或多个实体)进行通信的规则的集合。 在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务，要实现本层协议，还要使用下面一层所提供的的服务。 在同一系统中相邻两层的实体进行交互的地方，同城成为服务访问点SAP。实际上是个逻辑接口。 TCP/TP的体系结构TCP/IP可以为各式各样的应用提供服务 TCP/IP允许IP协议在各式各样的网络构成的互联网上运行 章节重要概念 计算机网络(可简称为网络)把许多计算机连接在一起，而互连网则把许多网络连接在一起，是网络的网络。 以小写字母i开始的internet(互连网)是通用名词，泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议可以是任意的。 以大写字母I开始的Internet(互联网)是专用名词，指当前全球最大的、开放的、且由众多网络相互连接而成的特定互连网，采用TCP/IP协议族作为通信规则，前身是美国的ARPANET。 互联网现在采用存储转发的分组交换技术，以及三层ISP结构。 互联网按工作方式可划分为边缘部分与核心部分。主机在网络的边缘部分，其作用是信息处理。路由器在网络的核心部分，作用是按存储转发方式进行分组交换。 计算机通信是计算机中的进程之间的通信。计算机网络采用的通信方式是客户-服务器方式和对等连接方式。 客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。 按作用范围的不同，计算机网络分为广域网WAN、城域网MAN、局域网LAN和个人区域网PAN。 计算机网络最常用的性能指标是：速率、带宽、吞吐量、时延(发送时延、传播时延、处理时延、排队时延)、时延带宽积、往返时间和信道(或网络)利用率。 网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层及其协议的集合，称为网络的体系结构。 五层协议的体系结构由应用层、运输层、网络层(或网际层)、数据链路层和物理层组成。运输层最重要的协议是TCP和UDP协议，而网络层最重要的协议是IP协议。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2019%2F07%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[滴滴滴，密码卡(｀・ω・´) Incorrect Password! No content to display! U2FsdGVkX1+mBMFKoiBkOG9PpO/GzRMsi2PccDCvwmJmNDehNJq0Mcom48L33UzluZKt1vDUipIR/Y0E5e747pgeVD+LCTU/1W5fWML7+2dGB1mjf2g6Ws4NP4joIlayp5qYucT2jG8E0wcm+JajxMQXxbBnnyUZ4MfWTie3WC/TyTAIPJZbp8c0FrkOpfOXiubDTUQQgB7+jW1fGqyml/tIu6RZThh65hk+UutVNfBB/M9+Cy9hqQ4Dn0RmqpfQDs0pdku85MTxunuhjvJM/kt2wT0I1OZpMYxjIKQSIV2WBNM9BWavNFI4Wu8BPIZ1D5nWS+XlB0X/fPPZEBcm8LdhNuq9aQJhhlL2S/9Jo+RXA39pCvX2xXkWhxhXVQGKQz007N+yVzOimSLYNPzgNFScTCJcINWSCTmIfm09mIANt4IqnR4jLfPemFAEoTTjyJ6C32eiLTdsdJPegNIbhgH7PDR+EIHGtxrXou59KbGFvGvgmHb+FbcatSbTCt7tR/4b1Ocfob63KE93Mxj0uDc5AWk93btUjZGKgLlOjE4ckFCVXb8zQK0yk0sGdeyvSZe478fZAOt66hGTBXipuhVEZAB9XDtJNrLF+LSOe4+VAZPxJMXCxOJh9vqjyctaxmHSBCW9iWGfMMt7JrrieicEbtvh4i+GcGBAymEMBdm7p+MjvuubNLIduFikyKOMl9LAYqSsQ13EH72VQ6csK2GKcigd9hc6bNTVXuWcSWuMWgJDZe3oMn7U7mG8ZR8q5Ef08j9IUjuhEYQHmIK+1mPJMB91U/t6XIhqjNYFp4W7DR2cpNBXckWjOmjZZp1CMy2gTRE2wqNugKStEewrkaMEkdfCNDvGp0Utj/D+OBR1UkEHZMqESyYNVz+G/iE2FUE0OcmZMKsQl3nIRukcCNTYRSo7sYjyTHW5D5xtmDGDvYuxxUXa25/ZHbmuLOtnXyKIlHNiDmGHczEIWc56SfSmxSP1XeUUvPc2uBO8tI5KYMTNdTYABYgcA9FVT9UyIKHjEM5xzGOmrwD0X24p+GPJ1murYpjEE40G+0pLOwCFNYYTKVDLY4gZVHffswomUX/K7nWjYz/BANfwHysszEifBN4Blh4YFS//GMIzm54X1fVU1oYzYATLbPImCmeWGDFeP89LCf+g7hKpi5g/PNfMC5XSxBZZQZs6DvC5Jz6z/yQgIcwJ/FMNOQvQ8pAtyLqAVMoqj9GZwn+nYq8k+47f4XJl6+Ub3TMBPZYjPFgTEelg/4n1yKvivE62rfz1eck7xNMbjrsfc6QPLC8+1tN7JNjXxa2lRL60ewhq+85w5ZewqPkmWMXJRu+oUBFawUR8Vz71CZ8wWK1tcAXJZu8BgjBmA6CodsRSmOX3MGbbgzpvChr+sQZsV25YuOG8Y+PHFyAYNXk7LB1xldZggVI1944Fc9WQb/DrbKrqCPVJNHSkZDeKFF34A2yjq+tTGTNmIqwg5/AqppuoSpIL9OjCbVtldjAWgOR1LqAgQH1je0dYHnww1tJtJOUMgvHlGl00aPgvjsyF35U73njTcweC4JSu/wC7/TXnXWMOBZRwVU8H5OfWsad1kK6SZP3q9uWxygk55DvIFhJnK4nUzf7XMkPSrdPQZi4YzIqryclgNJZ42L82ZhvQh4SyBzR1FuSKTwMl+h0mZrEAoqV1U3aPiNGO10p9rUY+JBB1h0jLlqMRAngQecOjbqIKPFYApCkgpq+roGCcMBtr/uGKI0ylqQwvzPtsZ0BfDTuWqb0xxRGgZpt88uXCYDawapojgd3ygFXc5JKIuTeFo/WOKPR6eNsesBEq1d3oDZHV7obSjvFwC7v+UeIyvcdf/BWQYlmM6LadSUmdUB9hlkZ/BC2EerR2eLGnkaoTZpoJNnEWjzYA9zPXBy05wCDxnsptZZPyRYxQgkMcmsTULMmIYccvp1FPh25SEc0Qo08Rr0uEE1ZddpMdAS8ezLbKdQCP7atrwX3c2PL7MS+muyWrSvHvfpMwawpU2Kju2dyp4Q9K5iTu7LdzTfP8VCxgMQRpCVc1F25/xLSrRVcKzK3xFRx0DXL2SbfGP9S2+kPyH98vN1JXNlmX+5wyPRjTC5UtzXYJoOSqwG9lJtMJLT4z1gSXX0/5RI+WX7BMP8lLWopiIjVuCceT74iS7yabr2CReH5siKs+8LUSvw5I4WLCYTx1erobxuB3IpY0uXN1ViFSAy172OcTdtgMB+ZMv5KOPKDiIDilVwF6EKR0lVDKN4F4s3FYMlNR1PfEZXEV+NTyfm86KGO7ugcAoaUOK3X9FNUma2msDs1gHjfPgYcyqIls16kgBTpZ2izrWyPXrsP8ybtuWPOWEyNvNbmF4P5XmOKH+roJ2hugtftbs/hiwFNBOHglpURCDZ6KCm1ReAsca1aNcpiHdoE+bSKwB6egcnprHfDlzYOj5rO/lZ4I1CBn8UOvM+isINcX8B6XI7kVZXzCqEBwQlxnniV/x8kqztWNr+9RSh6UKqYO5mgcrEJMYD/AdTRHDEE9Pbo4QreYmlHl5DindYA8ZQ55nUS+XK7k9mqA7ZycxiHofSJCX66Hs4nsbnsglfvJ0ouyXTM3sRNR8XQNFiblRVoMGZbjmQoDMS+EIv7TKcGb1ZsV78GMaVWCBFKkNBy32RYVssk8bVOC6USe/z3lsW9nKCTLukO7qmEk8XQQPNX3pR3EYu3J1x8J5aToloVr+R5xGY883RSCGWhuS8H7+Ctfm5xoVzamiw58j3muaJ6PEgXQWKeWNTzIUw7Evxlh2rO2Y77KN+7GZUMe0zGQepoTrRWJuVTvd6hFaTuaz/zc3rk0iuMHPFhu6vAp8QPpcW31kBjdgkHKUWslFl43wRq6L52xsLKzh/Vt95fQksoAxYXQorJFIDeNarqjNUY+QGh6+LlY6yxGJgZjp/K+NqHjM/UOBpZ2J+qp0aY3fDcD51tEmsQu2l+2q2nBKnvITc2kMyzmGh8ed9FNV82ROCorxdIlB24NxXAjs08WZMVIMJ+q+WVf76KJDwhENosNac/9WZQuvFCQkWPQi5EQa3HGaf8juTp1TblUmrs5YLgUI7x12mhAOiTKM4Fqi45c52/99vRLhGAibMMaaLH1+MIcDk2/ftEVrgQc/wkda0Dcq6QiGzr8+mQ7NY9sfVjkfuk0Sc21/4PqwXh3oBE5cd8eO6bg03dP8LTynHJu1eMpnWttSD49n3EyAJ2nb1GG60JCuhOgJr5ikMbGy/Ju/YBHU46HRVgJDsGVhZTMMy3NJOJeC1RVkcCSArf1e2fu91hZeQ5LDAQRNTYsBPYu5lVtGiMy0i87QtyugLcxl9/VVPkzrANAReV9YwI4mSSrS6AkazigAAs0ITnVHJR9kCQOTPsxJb3+eeX1DshGIQoVZstEUJD/HVfM8cdx/8AdFxv2YMSb68EkqKR0SheX6d29dxCx5KyMvhioWjNn5L6hqYTDAAbkC6lkpwMNtt4wuMA+Djo4Whk3PvxofJgO01DGxlu2YRJzdx8aji7EdsB8AgrSFO5seocqH5bfRGRtiII7c12zvGk1XJTq/bEuwNuA9TtT5pTE3Cdzh8DIReyQFPr7H7QDKXhvj1jxDTz9B+8M4H+FnieI8u5nWpJwM40GEljKEq0x5ul6q41laicBhFjCr8CGrEczp1+iE1e+mumiqdLsdKs7ntNRa0N38l49V7Y/wA7yse4i4dndDSkqAJneD32jw8JGySiCWrMXJ5y92ahT0KjuauNGcHRU0qJP9GIxztQv9sb1ZKPmRsQRP0pXiatNfoqwDnkc7V/ypwvBj9Uwazv3M10qGCGIR2njAiTpqDHH8eDcAljHZNOsfc407qU8yry9J+aOz8pTkU/DWVzb6eYBirjI8BxePPnLgqRkwSFDR/Cs3xH6awg2JUGttusIpt4gTHpByMGJJfB2Jom3FiIm/KJ3e8/Vr8/B8Y0ZMBC/pE0dIxGkDi1DiE2+/Xcqq9gTqznWGaJX02jr+Nu3M5yyVcf0sCFKn7BX2N90Efl1/hYNMQ+Za3hYGU/t5HQU5IMTBWkkTZo9avOKTTALM20f5Vn2itgfYSVKiqbWpUIXSo+1mJOlKh+sxo2cjor7ROX0G7TsTYUTKIQvIRoVjYYwXoR4vjwksKNBedveFn6fvYNie+wimohhjDddudm2n9eMNMoblU3J0uGyMgVpOPXFP6AF2R7bVc3BhM+dhWrWSQ2HCxmlSkyIvCcSsVJzwcMFSuG/RQ2AcRl459k/2g8+QJq2VdmzaCOSOXa56vaMGPu6RuEUDqQ8gqmNqsF+z2hrLLqHSUtgXMZa6aeR1aPlVTm8TwxnptefaLpE3JDnQpkAqBFai9K1L0GVAtqjOf+UR6i/bAXZxTI0wEIsT4IFw1HkkO5RcinZ8wAj5mEDx7+g3CztZvEMVI+GtFfvqWAdDSFhEdQDa3bQGb3xfta9jebYTawWjJ4ybHSImpWoWwkz/zKYTgB7e3YSnC4L59EkoIcnhvwS1iP4q/CVajRm0PuJYfc6C0lHk6fW95kbS3waIuyLqd4y3vx0jXbh1hinAA/k+YI/Lu/ckBGn4qr1ypKSJnlzSvZKbPUZRKM0O1pN52Dw7UyAQUIlCDuj97tqwu6coYCLCQWvprnE3PJL6RqqoW3AHNgmiz/rD8GxcwQGZrZL+O9IAlFXG1BAQa9Nmi50LIk/9vdlsBS3P4eQry3wc1Jb2MmUKhp7JBKISY/Ni0QRZ54mPY1P2EhclC/56CL3jYKE3pHIsbUgGKeMwCFC267Fd9p/aMfRNDkRxmO3Zs7yZPylHxVYBPm6U1oQu37BEr7U5LYHR1Ik3I/vUGNi8U+D6L4Yg4Lh9whoBUhNPjO2ACes9g1XHRSexZX/cMfPGEbqptQhbWLkm+GwrbJnjeMnvj41upWGAYhH++P6lsAfFlgvhGQws3pb0GvV59xs1h6lz6VHR/WTS7T+HeGRsQS3XsCZFrIG/7KvzTjXd0JtkfyFpFUXgcKH+COWpE5aGgDw9zmAHRR0DJjyVn+2QD9PkhiIeO5FxYXWnz/bLzePbuJ8PT5826webHi+RNGd6wE/w8IvmVb/TC5AwuwG4FwCTsasW/jcFW0Yw5LmC1XQQ2jhYoVLDzNkw054rRpZG7uA/7kzMah1p0CWQ8A2TOYq6XK6OekJJXtEyxeKv0Vnq23TvuSiArADZrseg6RWTwuc8HeAnPv776+kTXaGRgpQvBTB97ge6/tKg33HYDbwh258gdPG1gj/BL6Q2qHzCXPTS1Y4BPVfBzt0xX2MQZ19UzEKZb0VS/hwOAH2TAq6LRm9r6wTAnqRW4UQ0ltQuSAsJYPUc+NuUU5bPICGMDnhwpzhaPIAXzfV9ldikMfpGPR/aIMsc/KyOSyVAywgkfAdS00snqXaCQxpwrRj5NjboJVWo25kRSFflQVfJBfVzCD1LQZDQQajohK4Oltd5G7oUc35VQU6szUHis4bAy1NQHPM8e8h0R/a5cA3Dc9RgTCT85uadCJF9HVVvCd3boApRQeqImuR5F2ZMR3dj4ndcXT4nxemli4NxnABp3m1NRsTPkG1GGl+7G9nRvvpphYpIHfKxQUC5ZdmaHmSh5ddNZy6bXrMooYP1gvfzzo4wEd1CfppaknomPmOZBMt6LAsb1LT1ly5afnr2EmXDFlH9D73Rvt61sCBJ5EDOYu0W8YgpeIWeyLXDls5ALvWLuvXv8XGi5XzrnZOryeCSJXUNFWWYEUI9Kd9zIMJ6hq6DDL2MOGKAAoBDrSYn9gyE2pZagRGzVY/OGURbD0tQ3XWtLDMvWkYjjv3FO4Odph9+j9n7qS/LZ/tmVaHtn6U9THYFpHRyzCH0729vvh3vCVk4bzBGpWrchhEXXsalkdN0RmvqeXWdECjtTfYC/rfbDNYn0H91MjftKcKh243RcPQGM5O0Ypzfo+N1NPZrnrYx5DUl8S1Z7AlfJ5MCz/O52Yhuk6zWvcLJvwtKrpLumRJ1BvA0qpCFmGq+neYvo7aIMf2xQcwIF8aPHqGg+aFb43Upn8dhrmnp8bBkq8dA6UpwDzDuXHZN838wt+Dh0ktLaddRAVe9/OTcv68xRqv+KtI/d15gqMa8ou06sxEXu1DXIvCcOmsyFjMJzmNr7g0fikp+8VV1asGnJ0to/9X9a0Y/pstwXwwHMH6FDfFQMkwWwE0WjmZPj/OZy1Dx6bHU6mzqJpDiSV81L7Mc+wzKLmlJ89nZi/TadO0gVrJUOFuSocVW4jx+TwvnHC2Ad256e5suWUunuX80+aHRWIKAG14+PPzTE8/UKnOmamzdwdmtwUBN0luaNJAy6nTMJgkc9asGCkeQOTJhmiZPYUzVsm3OYfAyuf9PZQzfGST7TTzntoJrQSPH4jH7Q9pvXzUbRP7klSK85vQ0XqCCA7m2GwyJkigkLR+ddnJxeXnWX13oJ9wH7rLok/HCfNvRG3wXfSW9Z8vUxHtEMxLDjQ5Qz+pbNDPfoRQBckzAZKAvSu7+C+5/qonpLijt/b44u/YEbpxK+0rcpJgLza6qE2dFlMUjxMVBGQms4JXjI666WN2MQlIGWPEMyiYizdVUu/tocbTjJQtP+kVSp2IGdlQE5qQo1wfGYJvgUAzHjC0yNSuyQ8nPV+wwJLHs7H6TEY/mtWfvhk2U0EiBmZ1ktpBIWOOOxPea4OWBmi1Y9BV9SC3vrwzFuQgpcr44v9B/PvOejnDjq3gmsX6sh4Y7yiVNQ748zuIwplofWVPenNiS+NQzuNsGUGEuBsYf1bjpb17a6A1VlYectmmeBWCETQefqQv6tAdsym8MBrtLS/J0Psl1T2T6gcisLA6YkQ3LDnIEiBw1cef/3NZdtpvcQ8T1bmme/Xhz4iuaYbfOz4PV5ISEjVMo4FRuj34lcC3r1ZTq43ShCEX/j6nREFnruqIGhxv632SNyovClX6jrVbSJSTWNzAocCNryPRUTFPaQOSsfcZrdnBCU0C5irXyTZA2zu3IaevQW3rTDYa0/FSugJSxelus4+IV2NPtVl4rvmTFOb2SzEhFHdEDmb5PG8eK7fmj4VrJwpUrJ3gzwoTLu0kKIbqBHaoqo9IsK+N3MF4MA0GL8pMgVKdjKh8cvRKB+/EBRDrX39Ye7Z9nZCHomGbeVav/l3sBU/THDfZzOxxNL4xxDbuAGdALxMkRuYe7USPip4PHLYw0QKG+DNj4TYTZlmwcvknd8RTvGNQRZTlg7KWjrz459RyCJlA3LcoNSj+2I68ILyYla3/QVP5yOzy66mFUChYjK8wjpe4C+kZuOjgBTdFPwHG/BOGxBAyIWICJhowDqGY46AfvHWbBKOJGxcC5HOrpIBEkHHvPb5EAw8FdNJxF1fyukAh8cNhUXTQ+vgwKEY/UTTtHiKpn7DQ/jMJVFUlKbjRYWwdIpsh7ouBgAc61wBKiCaGHYn/p2qkY5Zfu4duEwd4ExEpwBSuTf3OMKwIUKKFZQJLcwaUQECLTJ2yxsHlfVB1MYByRBMYmOwXWAYuD/afVJM7G6mObZODxSKOvt0oMBMM0eBJAXYrLy7srIngLwv+iKFg8W+6zVpbpb98v7PSDmzGdM8jW8z+G+YENikim6PYJrgsGp9VdjJrH6eR50XNnMNI7dJI7yVzjX9vBwrU168LSay3NlLul299PNiYMJb7Y/AdnUCjNguYLaTSIHh3JO6gSBOH7SGe69SY1Q6J61Hz/qM4m0qqJNWSWGcLAl9JN1gw6Y/h2GwtWTZLLqBxt5a20HOyXZ/w4igkdCLcdD0MxPLQSyHRRpIkhywUPG7e8Ae6K49o5w3GBBLrkWW02K82xqrF9Q/J6hG5JpswanOULLs1Fj2BTWdtsAZJ2py8RPS+sfumJUrDFZ8d4xeVbXMNZxDfpI99o6njgMqaRnEDdEcgA9JElcELbPaum+uPsiqn7DF9F21K7+/dpK7+YG6rFP5LgHFMLe/CyXQchqlaH0BPoV78vJI3XFXMk6BQZefDGShuMbvWpEGgdU/1lDTBbnZ9+OhXvF/1GtIJF0s2b8GDo1KcZ2Kz8K4gXXhAJNhtOc2rvti6HfZ78c6/PNNc5UNPebyxlUkmyXNW1LPF+Sn6hRaE8kgkaDG9cm60fJ5Xcz96GHeO5qwMwZIc5C4ZaCopmM8M3VozPoXn25GcvCtaLDVRwP6YZMoiou5V27RzFxhrIxniJjrX5rZ1HWWpsUAqMp99hWDyiMfhtlqXpZl8bzxwwqvX+W5nirUxOyHqLNYjjaLRTFqnXZu3CUv9QYYiO2SSuzVw5IWigOhBKaJg6Golg9Y3llooqSEeWaE/asOOKLRNlDAC1KYVRU/HFe3f9H2+YH7Nff6uKelVktMdwV66Nm9OoKOxZ/MfkWREFEDC8d0JZP+8VJBXNQW19yzQVH2O13ZKHiPj98UikrYHMKhh446j+oXoO/6PXk1BB9D66Ygj3JiElxjZs53TZCi1duXGF0dRdMBBD2FgBSRQAV1KK+FL4vpcB6yVdLzk6wWI3IJ9PLKlZhtTiT2SSMjMAxCAEp4xlbW853deUsKbYAnBxWnK14OnbPOcl37IyrSx7shpILzJkxysiPJBQP7iy7ABDLHJATS+g0q9VN8BFcMXH6Q/xdo0EIyPdm8Ck1PpjZ2gsWnUbg9JUSBhYQf8n5TBkkOozcggELsGTfIig3yfrC+b2SFqMJnKr+PVAOqDrQCXPJgpkbQEo1qi7Ul6cEtxfKfAGTbequcGYjwrPSoKOkQu+s10sSaBqOHugSdhJT2EhJp3HEFAnHh3My0XSYTwEqPM8EWP1XlBHndiixO4jjNeJE1AFAyf1YUkX/qx8pA+aSIsKUuh02KsBp2KPN2En6w262DnXNozodMI3DF00P1ZHBRlbOEYNXokB4qyxw2lGfF7hg6GMSNGZJqKgzINTha/1Mgru6Gt8NJhH0GDzP9yCXkQWJOKpbF0mc1jlmxJbnXhB/CQDAa/LtnY0ZUZxto567W49ilP/JjWoG5Etcf2l6XRazEtsxb+lLIxC/TPhEZk63rx7nuk8ZoKIzY2FXBHhhLk/beCSToVsh4fs+gK4p3JGSmFI/4zVyjeRumt8Dtoki4wesqpf38bPFgTnwV1lT7TsIepSYJ/kxsk++aKOl7jvwhbzkyfcM8I/n89cLxpYo68lEO4lqz1AlJbzZhD4eA4X9qvViIXQySgPu1QgPVDLY5soFjpEyTGd8oPiIjhX6WbfwNxfQnb7NSuFa0ZrrZEEFOk03cfyQIUcP3SzsbrpJUP7MFy6KmtYYFzXGdOOdSn1MA9CsAAeOj/59HVk7Jrf5lRYNmKQdP75mVtxhb4tKpMPkf7CRTiQUMpl+ZvxRNPOtpBooSs0gJRAzW6rD+TjyBHrQOLyNC5WCW5BEExqn9j5KQlr106yycEX7NHWgL6INZ/D1Wd74Mz6SHuOUAbDlPv8uyDqURpGbDIOoQZmSYZn2mdxt5mNk710B5IPE8lyLvPwzlMUAqRXV9srMe40eaHsqQucRgpGkfx7KG4RWc6Ebaop9fQCPs3Z1Weq8dHmFqvNfOKsMbflSZ9roolfr00XmTG4bkCBAEubZrT6pr1/WPePHAbdqu/TRVq04KMNDzOp+bVC038zqMxwyOYgMQ3SbSOySf+Ee81JJZwwRzFkSI/3/0Bqcmg716Jkap/9XLF9mnbIX3X5CoMYNV/zw/h3l0uTGGABzx/sQBsjknNzUcsZ5jhGSbZ9IZ40Nx1DOGU+e4EcdLhJJGPZzPgSGpBhPa4uk42ZpXBa+XEEayqRcIGBv9BW/MCHLk1hIHC8qrTsgxng4CSIYWvkibYbMCf/8No7VyRTF/O6vCTg+mHnR83pSxw/TnJX0K14AQxiYZxH3mlkR5XSM1D6gofxU2ZsAhImmD48W8gXPwXTETyyqedtRR6vOvEWmuZTItBYlR0VWfzeIrkTr57MSdcHqNUL2XqaSXTdXmiNvAChrX2MSJD9Px6Apr3ZbwaJtyc7jwaWdPbIeTzOI4HG642vbY0hrWx5dXpcROqUDyfGYGQfy+zb8hD2jInmN/cNtjdDhRXq/j1y7VRuXA6iI6XSMa6Fa9ulpY3ZAwA]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++编程规范]]></title>
    <url>%2F2019%2F07%2F26%2FC-C-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[文件结构&#160; &#160; &#160; &#160;每个C/C++程序通常分两个文件：一个是用于保存程序的声明，称为头文件，以”.h“为后缀；另一个是保存程序的实现，称为定义，通常以”.cpp“为后缀(个别系统以”.cc“或”.cxx“为后缀；C程序以”.c“为后缀)。 版权和版本的声明声明位于头文件和定义文件的开头，包括： ​ 1.版权信息 ​ 2.文件名称，标识符，摘要 ​ 3.当前版本号，作者，修改者，完成日期 ​ 4.版本历史信息 12345678910111213141516171819/*Copyright (c) 2019. 樱落成雪的博客ALL rights reserved.文件名称：C/C++编程规范.md文件标识：摘要：有关C语言和C++的部分编程规范*/……代码…………代码……/*当前版本：1.1.0作者：Snowakura完成日期：2019.07.27原版本：原作者：原完成日期：*/ 版本标识：&lt;主版本号&gt;.&lt;次版本号&gt;.&lt;修订号&gt; Liunx核心约定：如果次版本号是偶数则代表正式版本，若为奇数则代表该版本为开发过程中的测试版本修订号则相当于Build号 头文件的结构头文件由三部分组成： ​ 1.头文件开头处的版权和版权声明(详见1.1) ​ 2.预处理块 ​ 3.函数和类结构声明 规则建议1.为了防止头文件被重复引用，应当用idndef/define/endif结构产生预处理块 2.用#include 格式引用标准库的头文件 3.用#include “filename.h”格式引用非标准库(用户自定义)的头文件1.头文件只存放声明而不存放定义 2.不提倡使用全局变量，尽量不在头文件中出现extern int value 这类声明 定义文件的结构定义文件由三部分组成： ​ 1.定义文件开头处的版权和版权声明(详见1.1) ​ 2.对头文件的引用 ​ 3.程序具体实现 目录结构如果头文件数目较多，应将头文件与定义文件分开保存以便维护。 如果部分文件为私有文件，则可以将其存放于另外的同一个目录下。 程序版式空行规则1.在每个类声明、函数定义结束之后都要加空行 2.在一个函数体内，逻辑上密切相关的语句之间不加空行，其他地方加空行分隔 1234567891011void Function1()&#123; ...&#125;void Function2()&#123; ...&#125; 1234567891011121314while (condition)&#123; statement-listA;​ if (condition)​ &#123;​ statement-listB;​ &#125;​ statement-listC;&#125; 代码行规则建议1.一行代码只做一件事情，只定义一个变量或只写一条语句 2.if, for, while, do 等语句自占一行，执行语句加{}防止书写失误 123456789int a = 1;int b = 2;while (a &lt; 5)&#123; a += b;&#125;尽可能在定义变量的同时初始化该变量 1234int a = 1;int b = 2; 代码行内的空格规则建议1.关键字之后要留空格，函数名之后不留空格以和关键字区别 2.‘(’ 向后紧跟， ‘)' ’,‘ ’;' 向前进跟，紧跟不留空格 3.‘,’ 之后要留空格，如果 ';' 不是一行的结束则后留空格 4.二元操作符前后加空格，一元操作符前后不加空格，'[]' ‘.’ '->' 前后不加空格 1234567void Function1(int x, int y, int z);for (i = 0; i &lt;= 5; i++)&#123; ch[i] += p-&gt;val;&#125;对于表达式比较长的for语句和if语句，为了紧凑起见可以适当去掉一些空格 123456for (i = 0; i&lt;10 &amp;&amp; i&gt;5; i++)&#123; statement-list;&#125; 对齐规则1.程序分界符 '{}' 应该独占一行且位于同一列，同时与引用他们的语句左对齐 2.‘{}’ 之内的代码块在 '{' 右边数格处左对齐 1234567891011void Function()&#123; ...&#125;if (condition)&#123; statement-list;&#125; 长行拆分规则1.代码行最大长度应控制在70~80个字符之内，不宜过长 2.长表达式在低优先级操作符处拆分成新行，操作符放在新行之首，拆分出新行应适当缩进 1234567891011121314void Function(Long_ElemType Long_ElemType_a)&#123; Long_ElemType Long_ElemType_b = 2; for (Long_ElemType_b; Long_ElemType_b * Long_ElemType_a &lt; 10; Long_ElemType_b++) &#123;​ statement-list;​ &#125;&#125; 修饰符的位置规则修饰符 ‘*’ 和 ‘&’ 紧靠变量名 12int a = 1;int *p = &amp;a; 注释规则1.注释不可过多，注释只是对代码的提示而不是文档 2.若代码本来就是易懂的则不需再加注释 3.边写代码边注释，修改代码的同时修改注释，以保证其一致性 4.尽量避免在注释中使用缩写 5.注释的位置应与被描述代码相邻，可上可右不可下 6.当代码比较长，尤其有多重嵌套时，应在一些段落结束处适当添加注释 类的版式 &#160; &#160; &#160;&#160;&#160;类提供关键字public、protected、private，分别用于声明哪些数据和函数是共有的、受保护的、私有的。让类仅仅公开必须要让外界知道的内容，而隐藏其它一切内容。 类的版式主要有两种方式： ​ 1.将private类型的数据写在前面，将public类型的函数写在后面。该类主张类的设计“以数据为中心”，重点关注类的内部结构。 ​ 2.将public类型的函数写在前面，将private类型的数据写在后面。该类主张类的设计”以行为为中心“，重点关注类提供什么接口。 建议建议采用“以行为为中心”的书写方式，即首先考虑类应该提供什么样的函数，这样做不仅让自己在设计类时思路清晰，而且方便别人阅读。 123456789class class-name&#123; public: public-member1; public-member2; private: private-member1; private-member2;&#125; 命名规则共性规则命名的两个基本原则：含义清晰，不易混淆；不和其他模块互相冲突。 规则建议1.标识符应当直观且可以拼读，可望文知意，不必进行"解码"。 ​ 标识符最好采用英文单词或其组合，便于记忆和阅读。用词应当准确。 2.标识符长度应当符合"min-length && max-information"原则。 ​ 名字可以长但没必要长时不用可以长。 3.命名规则尽量与所蔡永德操作系统或开发工具的风格保持一致。 ​ Windows风格是”大小写”混排，Unix风格是”小写加下划线”。 4.程序中不要出现仅靠大小写区分的相似的标识符。 1// int w, W; 5.程序中不要出现标识符完全相同的局部变量和全局变量，尽管两者作用域不同。 6.变量的名字应当使用"名词"或者"形容词+名词"。 12int Value;int oldValue; 7.全局函数的名字应当使用"动词"或者"动词+名词"。类的成员函数应当只使用"动词"，被省略掉的名词就是对象本身。 12DrawBox(); // 全局函数box-&gt;Draw(); // 类的成员函数 8.用正确的反义词组命名具有互斥意义的变量或函数等。 12int minValue;int maxValue;尽量避免名字中出现数字编号，除非逻辑上的确需要编号。 12// int Value1;// int Value2; Windows应用程序命名规则规则1.类名和函数名用大写字母开头的单词组合而成。 12class LeafNode; // 类名void SetValue(int value); // 函数名 2.变量和参数用小写字母开头的单词组合而成。 1int drawMode; 3.常量全用大写的字母，用下划线分割单词。 1const int MAX_LENGTH = 100; 4.静态变量加前缀s_ (表示static)。 1static int s_initValue; // 静态变量 5.如果需要定义全局变量，则加前缀g_ (表示global)。 1int g_howMuchMoney; // 全局变量 6.类的数据成员加前缀m_ (表示member)，可避免数据成员与成员函数的参数同名。 12345void Object::SetValue(int width, int height) &#123;​ m_width = width;​ m_height = height;&#125; 7.为了防止某一软件库中的一些标识符和其它软件库中的冲突，可以为各种标识符加上能反应软件性质的前缀。 ​ 三维图形标准OpenGL的所有库函数均以gl开头，所有常量均以GL开头。 Linux应用程序函数命名规则规则1.属于某一模块的函数，加上前缀，前缀为模块缩写。 2.函数名应该标明函数意义，格式为"前缀_名词_动词"。 表达式和基本语句运算符的优先级规则如果运算符较多，则用括号确定表达式的操作顺序，避免使用默认的优先级，也为防止产生歧义并提高可读性。 复合表达式复合表达式书写简洁且可以提高编译效率，但不可滥用复合表达式。 规则1.不编写太复杂的复合表达式。 1.不编写有多用途的复合表达式。 1.不将复合表达式和"真正的数学表达式"混淆。 123// i = a &gt; b &amp;&amp; c &gt; d &amp;&amp; c &lt;= e % f; // 太复杂// d = (a = b + c) + r; // 多用途// if (a &lt; b &lt; c) // 复合表达式(×)数学表达式(√) if 语句布尔变量与零值比较规则不可将布尔变量直接与TRUE、FALSE或者1、0进行比较。 1.不编写有多用途的复合表达式。 1.不将复合表达式和"真正的数学表达式"混淆。 TRUE和FALSE的值没有统一标准，例如Visual C++中TRUE被定义为1，Visual Basic中TRUE被定义为-1。 12345678bool a;// 标准if 语句if (a)if (!a)// 不良风格if (a == TRUE)if (a == 1) 整型变量与零值比较规则应当将整型变量用 "==" 或 "!=" 直接与0比较。 12345678int a;// 标准if 语句if (a == 0)if (a != 0)// 不良风格，易被误解为a是bool变量if (a)if (!a) 浮点变量与零值比较规则不可将浮点变量用"==" 或 "!=" 与任何数字比较。 无论float 还是double 类型的变量，都有精度限制。 1234567float a;//不良风格if (a == 0.0) // 隐含错误比较// 标准语句if ((x &gt;= -EPSINON) &amp;&amp; (x &lt;= EPSINON)) //其中EPSINON是允许的误差(即精度) 指针变量与零值比较规则应当将指针变量用 "==" 或 "!=" 与NULL比较。 指针的零值被记为NULL，尽管值与0相同，但其意义不同。 12345678int *p;//不良风格if (p == 0)if (p)// 标准语句if (p == NULL) // 显式比较，强调p为指针变量 循环语句的效率C/C++中，使用频率从高到低为for &gt; while &gt; do。 建议1.再多重循环中，如果有可能，将最长的循环放在最内层，最短的放在最外层。可以减少CPU跨切循环层的次数。 1234567891011121314151617//低效率(长循环在外层)for (row = 0; row &lt; 100; row++)&#123;​ for (col = 0; col &lt; 5; col++)​ &#123;​ sum = sum + row + col;​ &#125;&#125;// 高效率(长循环在内层)for (col = 0; col &lt; 5; col++)&#123;​ for (row = 0; row &lt; 100; row++)​ &#123;​ sum = sum + row + col;​ &#125;&#125; 2.如果循环体内存在逻辑判断，且循环次数很大，最好将逻辑判断移到循环体的外面。 1234567891011121314151617181920//效率低但程序简洁for (i = 0; i &lt; N; i++)&#123;​ if (codition)​ DoSomething();​ else​ DoOtherthing();&#125;// 效率高但程序不简洁if (condition)&#123;​ for (i = 0; i &lt; N; i++)​ DoSomething();&#125;else&#123;​ for (i = 0; i &lt; N; i++)​ DoOtherthing();&#125; for 语句的循环控制变量规则建议不可在for 循环体内修改循环变量，防止for 循环失去控制。建议for 语句的循环控制变量的取值采用"半开半闭区间"写法。 1234567891011//0 ≤ x ＜N 为半开半闭区间，写法直观for (int x = 0; x &lt; N; x++)&#123;​ statement-list;&#125;// 0 ≤ x ≤ N 为闭区间for (int x = 0; x &lt;= N - 1; x++)&#123;​ statement-list;&#125; switch 语句规则1.每个case 语句的结尾加break，否则将导致多个分支重叠(除非有意)。 2.最后加default分支，既是不需要default处理，也要在default后加break。 goto 语句少用慎用尽量不用 常量const与#define的比较C++可以定义const常量(const)，也可以定义宏常量(#define)，优缺点： const常量有数据类型， 宏常量没有数据类型。编译器对const可以进行类型安全检查，而对#define只进行字符替换，并没有类型安全检查，并且字符替换可能会产生意料不到的错误(边际效应)。 有些IDE可以对const常量进行调试，但不能对宏常量进行调试。 规则1.尽量使用含义直观的常量来表示那些将在程序中多次出现的数字或字符串。 2.在C++程序中只使用const常量而不使用宏常量。 常量定义规则规则1.需要对外公开的常量放在头文件中，不需要对外公开的常量放在定义文件的头部。为便于管理，可以把不同模块的常量集中存放在一个公共的头文件中。 2.如果某一常量与其它常量密切相关，应在定义中包含这种关系，而不应给出一些孤立的值。 12const float RADIUS = 100;const float DIAMETER = RADIUS *2; 函数设计一个函数的注释信息如下例： 12345678910111213141516/***************************************************************** Function: calculate The area of rectangle ** parameter: the Length and Width of rectangle ** outout: the area of rectangle ******************************************************************/int main()&#123; …………&#125;/*Error: 1.描述在单元测试中出现的错误 2.…………*/ 参数的规则规则建议1.参数的书写要完整，不要贪图省事只写参数的类型而省略参数名字。如果函数没有参数，则用void填充。 123456// 良好的风格void SetValue(int height, int width);float GetValue(void);// 不好的风格void SetValue(int, int);float GetValue(); 2.参数命名要恰当，顺序要合理。(参数名字最好带有意义，另外将目的参数放在前面，源参数放在后面) 3.如果参数是指针，且仅作输入用，则应在类型前加const，以防止该指针在函数体内被意外修改。 4.如果输入参数以值传递的方式传递对象，则宜改用"const&"方式来传递，这样可以省去临时对象的构造和析构过程，提高效率。 5.参数缺省值只能出现在函数的声明中，而不能出现在定义体中。 6.如果函数有太多的参数，参数只能从后向前依次缺省。1.避免函数有太多的参数，参数个数尽量控制在5个以内。参数过多容易记错。&lt;/br&gt; 1.尽量不要使用类型和数目不确定的参数。&lt;/br&gt; 返回值的规则规则1.不要省略返回值的类型，没有应声明为void类型。 2.函数名字与返回值类型在语义上不可冲突。 3.不要将正常值和错误标志混在一起返回。正常值用输出参数获得，而错误标志用return语句返回。 4.给以"指针传递"方式的函数返回值加const修饰，那么函数返回值(即指针)的内容不能被修改，该返回值只能被赋给加const修饰的同类型指针。 5.函数返回值采用"值传递方式"，由于函数会把返回值复制到外部临时的存储单元中，加const修饰没有任何价值。 6.函数返回值采用"引用传递"的场合并不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。 函数内部实现的规则规则1.在函数体的"入口处"，对参数的有效性进行检查。 2.在函数体的"出口处"，对return语句的正确性和效率进行检查。 return语句不可返回指向”栈内存”的”指针”或者”引用”，因为该内存在函数体结束时被自动销毁。123456char * Func(void)&#123; char str[] = "hello world"; // str 的内存位于栈上 …… return str; // 将导致错误&#125; 要搞清楚返回的究竟是”值”、”指针”还是”引用”。 如果函数返回值是一个对象，要考虑return 语句的效率。 其他建议建议1.函数的功能要单一，不要设计多用途的函数。 2.函数体的规模要小，尽量控制在50行代码之内。 3.尽量避免函数带有"记忆"功能。相同的输入应当产生相同的输出。在C/C++中函数的static局部变量是函数的"记忆"存储器，建议尽量少用static局部变量，除非必需。 4.不仅要检查输入参数的有效性，还要检查通过其他途径进入函数体内的变量的有效性，例如全局变量，文件句柄等。 5.用于出错处理的返回值一定要搞清楚，让使用者不容易忽视或误解错误情况。 使用断言 &#160; &#160; &#160; &#160;程序一般分为Debug 版本和Release 版本，Debug 版本用于内部调试，Release 版本发行给用户使用。&#160; &#160; &#160; &#160;断言assert 是仅在Debug 版本起作用的宏，它用于检查“不应该”发生的情况。在运行过程中，如果assert 的参数为假，那么程序就会中止（一般地还会出现提示对话，说明在什么地方引发了assert）。&#160; &#160; &#160; &#160;assert 不是一个仓促拼凑起来的宏。为了不在程序的Debug 版本和Release 版本引起差别，assert不应该产生任何副作用。所以assert 不是函数，而是宏。程序员可以把assert 看成一个在任何系统状态下都可以安全使用的无害测试手段。如果程序在assert处终止了，并不是说含有该assert 的函数有错误，而是调用者出了差错，assert 可以帮助我们找到发生错误的原因。 ——引用自原文件 规则建议1.使用断言捕捉不应该发生的非法情况，不要混淆非法情况与错误情况之间的区别，后者是必然存在的而且是一定要作出处理的。 2.在函数的入口处，使用断言检查参数的有效性(合法性)。1.在编写函数时，要进行反复的考查，并且自问："我打算做哪些假定?"。一旦确定了的假定，就要使用断言对假定进行检查。 2.当进行防错设计时，如果"不可能发生"的事情的确发生了，则要使用断言进行报警。 引用与指针的比较引用的规则： 引用被创建的同时必须被初始化，指针则可以在任何时候被初始化。 不能用NULL 引用，引用必须与合法的存储单元关联，但指针可以是NULL。 一旦引用被初始化，就不能改变引用的关系，指针则可以随时改变所指的对象。 重载和内联普通函数重载规则1.重载函数中的参数不同(包括类型、顺序不同)，才是重载函数，而仅仅返回值不同则不行。 2.当心隐式类型转换导致重载函数产生二义性，数字本身没有类型，将数字当做参数时将自动进行类型转换(成为隐式类型转换)。 成员函数的重载覆盖与隐藏规则1.成员函数的重载、覆盖与隐藏很容易混淆，注意区分。 2.注意如果派生类的函数与基类的函数同名，但是参数不同。此时，无论有无virtual关键字，基类的函数将被隐藏(注意别与重载混淆)。 3.注意如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏(注意别与覆盖混淆)。 内联函数规则1.尽量用内联取代宏代码，提高函数的执行效率(速度)。 2.关键字inline必须与函数定义体放在一起才能使函数成为内联，仅将inline放在函数声明前面不起任何作用。 3.如果函数体内的代码比较长或函数体内出现循环，则不宜使用内联。 内存管理内存分配方式分三种： 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在，例如全局变量，static变量。 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但分配的内存容量有限。 从堆上分配，也称为动态内存分配。程序在运行的时候用malloc 或new 申请任意大小的内存，程序员自己负责在何时用free 或delete 释放内存。使用非常灵活，但问题也最多。 规则1.用malloc 或new 申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。 2.不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。 3.避免数组或指针的下标越界，特别要当心发证"多1"或者"少1"操作。 4.动态内存的申请与释放必须配对，防止内存泄漏。 5.用free 或delete 释放了内存之后，立即将指针设置为NULL，防止产生"野指针"。 类的构造函数、析构函数、成员函数、赋值函数类的构造函数规则1."缺省的拷贝构造函数"和"缺省的赋值函数"均采用"位拷贝"而非"值拷贝"的方式来实现，若类中含有指针变量，不能采用缺省的方式。 2.如果类存在继承关系，派生类必须在其初始化表里调用基类的构造函数。 3.类的const 常量只能在初始化表里被初始化，因为它不能在函数体内用赋值的方式来初始化。 4.非内部数据类型的成员对象采用初始化表的方式初始化较好。 5.拷贝构造函数和赋值函数非常容易混淆，常导致错写、错用。拷贝构造函数是在对象被创建时调用的，而赋值函数只能被已经存在了的对象调用。 成员函数规则1.任何不会修改数据成员的函数都应该声明为const 类型。 2.如果类存在继承关系，派生类必须在其初始化表里调用基类的构造函数。 3.类的const 常量只能在初始化表里被初始化，因为它不能在函数体内用赋值的方式来初始化。 4.非内部数据类型的成员对象采用初始化表的方式初始化较好。 5.拷贝构造函数和赋值函数非常容易混淆，常导致错写、错用。拷贝构造函数是在对象被创建时调用的，而赋值函数只能被已经存在了的对象调用。 类的继承和组合规则1.如果类A和类B毫不相关，不可以为了使B的功能更多些而让B继承A的功能和属性。 2.若在逻辑上B是A的"一种情况"，则允许B继承A的功能和属性。 3.若在逻辑上A是B的"一部分"(a part of)，则不允许B从A派生，而是要用A和其他东西组合出B。 其他规范及建议提高程序的效率规则1.不要一味地追求程序的效率，应当在满足正确性、可靠性、健壮性、可读性等质量因素的前提下，设法提高程序的效率。 2.以提高程序的全局效率为主，提高局部效率为辅。(全局效率是指站在整个系统的角度上考虑的效率，局部效率是指站在模块或函数角度上考虑的效率) 3.在优化程序的效率时，应当先找出限制效率的"瓶颈"，不要在无关紧要之处优化。 4.先优化数据结构和算法，再优化执行代码。 5.有时候时间效率和空间效率可能对立，此时应当分析哪个更重要，作出适当的折中。 6.不要追求紧凑的代码，因为紧凑的代码并不能产生高效的机器码。 一些有益的建议建议1.当心那些视觉上不易分辨的操作符发生书写错误。我们经常会把"=="写成"="，其他符号也很容易发生"丢失"失误，然而编译器却不一定能自动指出这些错误。 2.变量(指针、数组)被创建之后应当及时把它们初始化，以防止把为被初始化的变量当成右值使用。 3.当心变量的初值、缺省值错误，或者精度不够。 4.当心数据类型转换发生错误。尽量使用显式的数据类型转换，避免让编译器悄悄的进行隐式数据类型转换。 5.当心变量发生上溢或下溢，数组的下标越界。 6.当心忘记编写错误处理程序，当心错误处理程序本身有误。 7.当心文件I/O有误。 8.避免编写技巧性很高的代码。 9.不要设计面面俱到、非常灵活的数据结构。 10.如果原有的代码质量比较好，尽量复用它。但是不要修补很差劲的代码，应当重新编写。 11.尽量使用标准库函数，不要"发明"已经存在的库函数。 12.尽量不要使用与具体硬件或软件环境关系密切的变量。 13.把编译器的选择项设置为最严格状态。 14.如果可能的话，使用LogiScope等工具进行代码审查。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
